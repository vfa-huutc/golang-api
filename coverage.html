
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>seeder: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/vfa-khuongdv/golang-cms/cmd/seeder/seeder.go (0.0%)</option>
				
				<option value="file1">github.com/vfa-khuongdv/golang-cms/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/vfa-khuongdv/golang-cms/internal/configs/database.go (0.0%)</option>
				
				<option value="file3">github.com/vfa-khuongdv/golang-cms/internal/configs/env.go (0.0%)</option>
				
				<option value="file4">github.com/vfa-khuongdv/golang-cms/internal/database/seeders/permission_seed.go (0.0%)</option>
				
				<option value="file5">github.com/vfa-khuongdv/golang-cms/internal/database/seeders/role_seed.go (0.0%)</option>
				
				<option value="file6">github.com/vfa-khuongdv/golang-cms/internal/database/seeders/seeder.go (0.0%)</option>
				
				<option value="file7">github.com/vfa-khuongdv/golang-cms/internal/database/seeders/user_seed.go (0.0%)</option>
				
				<option value="file8">github.com/vfa-khuongdv/golang-cms/internal/guards/permission_guard.go (0.0%)</option>
				
				<option value="file9">github.com/vfa-khuongdv/golang-cms/internal/handlers/auth_handler.go (100.0%)</option>
				
				<option value="file10">github.com/vfa-khuongdv/golang-cms/internal/handlers/health_handler.go (100.0%)</option>
				
				<option value="file11">github.com/vfa-khuongdv/golang-cms/internal/handlers/permission_handler.go (100.0%)</option>
				
				<option value="file12">github.com/vfa-khuongdv/golang-cms/internal/handlers/role_handler.go (100.0%)</option>
				
				<option value="file13">github.com/vfa-khuongdv/golang-cms/internal/handlers/setting_handler.go (91.7%)</option>
				
				<option value="file14">github.com/vfa-khuongdv/golang-cms/internal/handlers/user_handler.go (89.4%)</option>
				
				<option value="file15">github.com/vfa-khuongdv/golang-cms/internal/middlewares/auth_middleware.go (0.0%)</option>
				
				<option value="file16">github.com/vfa-khuongdv/golang-cms/internal/middlewares/cors_middleware.go (100.0%)</option>
				
				<option value="file17">github.com/vfa-khuongdv/golang-cms/internal/middlewares/empty_body_middleware.go (100.0%)</option>
				
				<option value="file18">github.com/vfa-khuongdv/golang-cms/internal/middlewares/log_middleware.go (0.0%)</option>
				
				<option value="file19">github.com/vfa-khuongdv/golang-cms/internal/repositories/permission_repository.go (100.0%)</option>
				
				<option value="file20">github.com/vfa-khuongdv/golang-cms/internal/repositories/refresh_token_repository.go (100.0%)</option>
				
				<option value="file21">github.com/vfa-khuongdv/golang-cms/internal/repositories/role_repository.go (100.0%)</option>
				
				<option value="file22">github.com/vfa-khuongdv/golang-cms/internal/repositories/setting_repository.go (100.0%)</option>
				
				<option value="file23">github.com/vfa-khuongdv/golang-cms/internal/repositories/user_repository.go (95.9%)</option>
				
				<option value="file24">github.com/vfa-khuongdv/golang-cms/internal/routes/routes.go (0.0%)</option>
				
				<option value="file25">github.com/vfa-khuongdv/golang-cms/internal/services/auth_service.go (100.0%)</option>
				
				<option value="file26">github.com/vfa-khuongdv/golang-cms/internal/services/bcrypt_service.go (90.9%)</option>
				
				<option value="file27">github.com/vfa-khuongdv/golang-cms/internal/services/jwt_service.go (87.5%)</option>
				
				<option value="file28">github.com/vfa-khuongdv/golang-cms/internal/services/mail_service.go (0.0%)</option>
				
				<option value="file29">github.com/vfa-khuongdv/golang-cms/internal/services/permission_service.go (100.0%)</option>
				
				<option value="file30">github.com/vfa-khuongdv/golang-cms/internal/services/redis_service.go (79.2%)</option>
				
				<option value="file31">github.com/vfa-khuongdv/golang-cms/internal/services/refresh_token_service.go (100.0%)</option>
				
				<option value="file32">github.com/vfa-khuongdv/golang-cms/internal/services/role_service.go (100.0%)</option>
				
				<option value="file33">github.com/vfa-khuongdv/golang-cms/internal/services/setting_service.go (100.0%)</option>
				
				<option value="file34">github.com/vfa-khuongdv/golang-cms/internal/services/user_service.go (63.5%)</option>
				
				<option value="file35">github.com/vfa-khuongdv/golang-cms/internal/utils/bcrypt.go (100.0%)</option>
				
				<option value="file36">github.com/vfa-khuongdv/golang-cms/internal/utils/env.go (100.0%)</option>
				
				<option value="file37">github.com/vfa-khuongdv/golang-cms/internal/utils/paging.go (100.0%)</option>
				
				<option value="file38">github.com/vfa-khuongdv/golang-cms/internal/utils/response.go (75.0%)</option>
				
				<option value="file39">github.com/vfa-khuongdv/golang-cms/internal/utils/security.go (83.1%)</option>
				
				<option value="file40">github.com/vfa-khuongdv/golang-cms/internal/utils/string.go (100.0%)</option>
				
				<option value="file41">github.com/vfa-khuongdv/golang-cms/internal/utils/validate.go (84.7%)</option>
				
				<option value="file42">github.com/vfa-khuongdv/golang-cms/pkg/apperror/app_error.go (100.0%)</option>
				
				<option value="file43">github.com/vfa-khuongdv/golang-cms/pkg/apperror/factory.go (0.0%)</option>
				
				<option value="file44">github.com/vfa-khuongdv/golang-cms/pkg/apperror/validation_error.go (0.0%)</option>
				
				<option value="file45">github.com/vfa-khuongdv/golang-cms/pkg/logger/logger.go (83.3%)</option>
				
				<option value="file46">github.com/vfa-khuongdv/golang-cms/pkg/mailer/smtp_mailler.go (100.0%)</option>
				
				<option value="file47">github.com/vfa-khuongdv/golang-cms/pkg/migrator/migrator.go (0.0%)</option>
				
				<option value="file48">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_auth_service.go (0.0%)</option>
				
				<option value="file49">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_bcrypt_service.go (0.0%)</option>
				
				<option value="file50">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_db.go (0.0%)</option>
				
				<option value="file51">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_jwt_service.go (0.0%)</option>
				
				<option value="file52">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_permission_repository.go (0.0%)</option>
				
				<option value="file53">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_permission_service.go (0.0%)</option>
				
				<option value="file54">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_redis_client.go (0.0%)</option>
				
				<option value="file55">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_redis_service.go (0.0%)</option>
				
				<option value="file56">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_refresh_token_repository.go (0.0%)</option>
				
				<option value="file57">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_refresh_token_service.go (0.0%)</option>
				
				<option value="file58">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_role_repository.go (0.0%)</option>
				
				<option value="file59">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_role_service.go (0.0%)</option>
				
				<option value="file60">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_setting_repository.go (0.0%)</option>
				
				<option value="file61">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_setting_service.go (0.0%)</option>
				
				<option value="file62">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_user_repository.go (0.0%)</option>
				
				<option value="file63">github.com/vfa-khuongdv/golang-cms/tests/mocks/mock_user_service.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/vfa-khuongdv/golang-cms/internal/configs"
        "github.com/vfa-khuongdv/golang-cms/internal/database/seeders"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
)

func main() <span class="cov0" title="0">{
        // Load env package
        configs.LoadEnv()

        // Init logger
        logger.Init()

        // MySQL database configuration
        config := configs.DatabaseConfig{
                Host:     utils.GetEnv("DB_HOST", "127.0.0.1"),
                Port:     utils.GetEnv("DB_PORT", "3306"),
                User:     utils.GetEnv("DB_USERNAME", ""),
                Password: utils.GetEnv("DB_PASSWORD", ""),
                DBName:   utils.GetEnv("DB_DATABASE", ""),
                Charset:  "utf8mb4",
        }

        // Initialize database connection
        db := configs.InitDB(config)

        // Run seeder
        seeders.Run(db)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"

        "github.com/vfa-khuongdv/golang-cms/internal/configs"
        "github.com/vfa-khuongdv/golang-cms/internal/routes"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
        "github.com/vfa-khuongdv/golang-cms/pkg/migrator"
        "gorm.io/gorm"
)

func initializeDatabase() *gorm.DB <span class="cov0" title="0">{
        config := configs.DatabaseConfig{
                Host:     utils.GetEnv("DB_HOST", "127.0.0.1"),
                Port:     utils.GetEnv("DB_PORT", "3306"),
                User:     utils.GetEnv("DB_USERNAME", ""),
                Password: utils.GetEnv("DB_PASSWORD", ""),
                DBName:   utils.GetEnv("DB_DATABASE", ""),
                Charset:  "utf8mb4",
        }
        return configs.InitDB(config)
}</span>

func runMigrations() <span class="cov0" title="0">{
        dsn := migrator.NewMySQLDSN(
                utils.GetEnv("DB_USERNAME", ""),
                utils.GetEnv("DB_PASSWORD", ""),
                utils.GetEnv("DB_HOST", "127.0.0.1"),
                utils.GetEnv("DB_PORT", "3306"),
                utils.GetEnv("DB_DATABASE", ""),
        )

        m, err := migrator.NewMigrator("internal/database/migrations", dsn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Migration initialization failed: %v", err)
        }</span>
        <span class="cov0" title="0">defer m.Close()

        if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Migration failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                logger.Infof("MySQL migrations applied successfully!")
        }</span>
}

func main() <span class="cov0" title="0">{
        // Load environment variables
        configs.LoadEnv()

        // Initialize logger
        logger.Init()

        // Initialize database
        db := initializeDatabase()

        // Run migrations
        isRunMigrate := utils.GetEnv("RUN_MIGRATE", "false")
        if isRunMigrate == "true" </span><span class="cov0" title="0">{
                runMigrations()
        }</span>

        // Setup routes
        <span class="cov0" title="0">router := routes.SetupRouter(db)

        // Initialize custom validator
        utils.InitValidator()

        // Start server
        port := fmt.Sprintf(":%s", utils.GetEnv("PORT", "3000"))
        if err := router.Run(port); err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package configs

import (
        "fmt"

        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"
)

type DatabaseConfig struct {
        Host     string
        Port     string
        User     string
        Password string
        DBName   string
        Charset  string
}

var DB *gorm.DB

// InitDB initializes a MySQL database connection using GORM
// Parameters:
//   - config: DatabaseConfig struct containing database connection parameters
//
// Returns:
//   - *gorm.DB: Database connection instance
//
// Note: Also sets the global DB variable with the connection instance
func InitDB(config DatabaseConfig) *gorm.DB <span class="cov0" title="0">{
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=%s&amp;parseTime=True&amp;loc=UTC",
                config.User,
                config.Password,
                config.Host,
                config.Port,
                config.DBName,
                config.Charset,
        )

        db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to connect to the MySQL database: %+v", err)
        }</span> else<span class="cov0" title="0"> {
                logger.Info("MySQL database connection established successfully")
        }</span>
        <span class="cov0" title="0">DB = db
        return db</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package configs

import (
        "github.com/joho/godotenv"
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
)

// LoadEnv loads environment variables from a .env file.
// If no .env file is found, it will use system environment variables instead.
// Uses godotenv package to load the environment variables.
func LoadEnv() <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                logger.Info("No .env file found, loading environment variables from the system.")
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package seeders

import (
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
        "gorm.io/gorm"
)

func SeedPermissions(db *gorm.DB) error <span class="cov0" title="0">{
        permissions := []models.Permission{
                // User resource permissions
                {
                        ID:       1,
                        Resource: "users", // Resource: User management
                        Action:   "index", // Action: List all users
                },
                {
                        ID:       2,
                        Resource: "users",  // Resource: User management
                        Action:   "create", // Action: Create new user
                },
                {
                        ID:       3,
                        Resource: "users",  // Resource: User management
                        Action:   "update", // Action: Update existing user
                },
                {
                        ID:       4,
                        Resource: "users", // Resource: User management
                        Action:   "view",  // Action: View user details
                },
                {
                        ID:       5,
                        Resource: "users",  // Resource: User management
                        Action:   "delete", // Action: Delete user
                },
                // Role resource permissions
                {
                        ID:       6,
                        Resource: "roles", // Resource: Role management
                        Action:   "index", // Action: List all roles
                },
                {
                        ID:       7,
                        Resource: "roles",  // Resource: Role management
                        Action:   "create", // Action: Create new role
                },
                {
                        ID:       8,
                        Resource: "roles",  // Resource: Role management
                        Action:   "update", // Action: Update existing role
                },
                {
                        ID:       9,
                        Resource: "roles", // Resource: Role management
                        Action:   "view",  // Action: View role details
                },
                {
                        ID:       10,
                        Resource: "roles",  // Resource: Role management
                        Action:   "delete", // Action: Delete role
                },
                // Settings resource permissions
                {
                        ID:       11,
                        Resource: "settings", // Resource: System settings
                        Action:   "view",     // Action: View settings
                },
                {
                        ID:       12,
                        Resource: "settings", // Resource: System settings
                        Action:   "update",   // Action: Update settings
                },
        }

        for _, permission := range permissions </span><span class="cov0" title="0">{
                if err := db.Create(&amp;permission).Error; err != nil </span><span class="cov0" title="0">{
                        logger.Infof("The permission %v, action %v was run before\n", permission.Resource, permission.Action)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package seeders

import (
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
        "gorm.io/gorm"
)

type RoleSeeder struct {
        Role          *models.Role
        PermissionIds []uint
}

func SeedRoles(db *gorm.DB) error <span class="cov0" title="0">{
        roles := []RoleSeeder{
                {
                        Role: &amp;models.Role{
                                ID:          1,
                                Name:        "Admin",
                                DisplayName: "Administrator",
                        },
                        PermissionIds: []uint{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, // Full access to all permissions
                },
                {
                        Role: &amp;models.Role{
                                ID:          2,
                                Name:        "User",
                                DisplayName: "Regular User",
                        },
                        PermissionIds: []uint{1, 4, 6, 9, 11}, // Can view users, roles, settings but not modify them
                },
        }

        for _, roleData := range roles </span><span class="cov0" title="0">{
                // Create new role
                if err := db.Create(&amp;roleData.Role).Error; err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error creating role %s: %v", roleData.Role.Name, err)
                        continue</span>
                }

                // Create role-permission associations
                <span class="cov0" title="0">for _, permID := range roleData.PermissionIds </span><span class="cov0" title="0">{
                        rolePermission := models.RolePermission{
                                RoleID:       roleData.Role.ID,
                                PermissionID: permID,
                        }
                        if err := db.Create(&amp;rolePermission).Error; err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Error adding permission %d to role %s: %v", permID, roleData.Role.Name, err)
                        }</span>
                }

                <span class="cov0" title="0">logger.Infof("Created role %s with %d permissions", roleData.Role.Name, len(roleData.PermissionIds))</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package seeders

import (
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
        "gorm.io/gorm"
)

// Run executes all seed functions to populate the database with initial data
// It takes a GORM database connection as input and panics if any seeding operation fails
func Run(db *gorm.DB) <span class="cov0" title="0">{

        // SeendPermissions seeds the permissions table
        if err := SeedPermissions(db); err != nil </span><span class="cov0" title="0">{
                logger.Infof("Something else error when run seeding permission: %+v", err)
        }</span>

        // SeedRoles seeds the roles table
        <span class="cov0" title="0">if err := SeedRoles(db); err != nil </span><span class="cov0" title="0">{
                logger.Infof("Something else error when run seeding user: %+v", err)
        }</span>

        // SeedUsers seeds the users table
        <span class="cov0" title="0">if err := SeedUsers(db); err != nil </span><span class="cov0" title="0">{
                logger.Infof("Something else error when run seeding user: %+v", err)
        }</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package seeders

import (
        "log"

        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
        "gorm.io/gorm"
)

type UserSeeder struct {
        User    *models.User
        RoleIds *[]uint
}

func SeedUsers(db *gorm.DB) error <span class="cov0" title="0">{
        users := []UserSeeder{
                {
                        User: &amp;models.User{
                                Name:     "John Doe",
                                Email:    "john@example.com",
                                Password: utils.HashPassword("password123"),
                        },
                        RoleIds: &amp;[]uint{1}, // Admin role
                },
                {
                        User: &amp;models.User{
                                Name:     "Jane Smith",
                                Email:    "jane@example.com",
                                Password: utils.HashPassword("password123"),
                        },
                        RoleIds: &amp;[]uint{2}, // User role
                },
        }

        for _, userData := range users </span><span class="cov0" title="0">{
                // Create new user
                if err := db.Create(&amp;userData.User).Error; err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error creating user %s: %v", userData.User.Name, err)
                        continue</span>
                }
                // Create user-role associations
                <span class="cov0" title="0">for _, roleID := range *userData.RoleIds </span><span class="cov0" title="0">{
                        userRole := models.UserRole{
                                UserID: userData.User.ID,
                                RoleID: roleID,
                        }
                        if err := db.Create(&amp;userRole).Error; err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Error adding role %d to user %s: %v", roleID, userData.User.Name, err)
                        }</span>
                        <span class="cov0" title="0">log.Printf("Created user %s with %d roles", userData.User.Name, len(*userData.RoleIds))</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package guards

import (
        "fmt"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/repositories"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
        "gorm.io/gorm"
)

// RoleGuard provides methods to check permissions for roles
type RoleGuard struct {
        roleRepo repositories.IRoleRepository
        userRepo repositories.IUserRepository
}

// NewRoleGuard creates a new RoleGuard instance with the provided database
func NewRoleGuard(db *gorm.DB) *RoleGuard <span class="cov0" title="0">{
        return &amp;RoleGuard{
                roleRepo: repositories.NewRoleRepository(db),
                userRepo: repositories.NewUserRepository(db),
        }
}</span>

// RequirePermissions returns a middleware that checks if the user has all required permissions
// It requires the auth middleware to be run first to set the user ID in the context
func RequirePermissions(guard *RoleGuard, requiredPerms ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get user ID
                userIdAny, exists := c.Get("UserID")
                if !exists </span><span class="cov0" title="0">{
                        utils.RespondWithError(
                                c,
                                apperror.NewForbiddenError("User ID not found"),
                        )
                        return
                }</span>

                <span class="cov0" title="0">userId := userIdAny.(uint)
                userPermSet := map[string]bool{}

                // Get user permissions
                permissions, err := guard.userRepo.GetUserPermissions(userId)
                if err != nil </span><span class="cov0" title="0">{
                        utils.RespondWithError(
                                c,
                                apperror.NewForbiddenError("Failed to retrieve user permissions"),
                        )
                        return
                }</span>

                // Aggregate permissions from all roles
                <span class="cov0" title="0">for _, p := range permissions </span><span class="cov0" title="0">{
                        permKey := fmt.Sprintf("%s:%s", p.Resource, p.Action)
                        userPermSet[permKey] = true
                }</span>

                // Check ALL required permissions are granted
                <span class="cov0" title="0">for _, required := range requiredPerms </span><span class="cov0" title="0">{
                        if !userPermSet[required] </span><span class="cov0" title="0">{
                                utils.RespondWithError(
                                        c,
                                        apperror.NewForbiddenError(fmt.Sprintf("Missing permission: %s", required)),
                                )
                        }</span>
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
)

type IAuthHandler interface {
        Login(c *gin.Context)
        RefreshToken(c *gin.Context)
}

type AuthHandler struct {
        authService services.IAuthService
}

func NewAuthHandler(authService services.IAuthService) *AuthHandler <span class="cov8" title="1">{
        return &amp;AuthHandler{
                authService: authService,
        }
}</span>

func (handler *AuthHandler) Login(ctx *gin.Context) <span class="cov8" title="1">{
        var credentials struct {
                Email    string `json:"email" binding:"required,email"`
                Password string `json:"password" binding:"required,min=6,max=255"`
        }

        if err := ctx.ShouldBindJSON(&amp;credentials); err != nil </span><span class="cov8" title="1">{
                validateErr := utils.TranslateValidationErrors(err, credentials)
                utils.RespondWithError(
                        ctx,
                        validateErr,
                )
                return
        }</span>

        // login handler
        <span class="cov8" title="1">res, err := handler.authService.Login(credentials.Email, credentials.Password, ctx)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, res)</span>
}

func (handler *AuthHandler) RefreshToken(ctx *gin.Context) <span class="cov8" title="1">{
        var input struct {
                RefreshToken string `json:"refresh_token" binding:"required"`
        }

        // Bind JSON request body to token struct
        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                validationErr := utils.TranslateValidationErrors(err, input)
                utils.RespondWithError(
                        ctx,
                        validationErr,
                )
                return
        }</span>

        // Call auth service to refresh the token
        <span class="cov8" title="1">res, err := handler.authService.RefreshToken(input.RefreshToken, ctx)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, res)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
)

func HealthCheck(ctx *gin.Context) <span class="cov8" title="1">{
        utils.RespondWithOK(ctx, http.StatusOK, gin.H{"status": "healthy"})
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
)

type IPermissionHandler interface {
        GetAll(c *gin.Context)
}

type PermissionHandler struct {
        service services.IPermissionService
}

func NewPermissionHandler(service services.IPermissionService) *PermissionHandler <span class="cov8" title="1">{
        return &amp;PermissionHandler{service: service}
}</span>

func (handlder *PermissionHandler) GetAll(ctx *gin.Context) <span class="cov8" title="1">{
        permissions, err := handlder.service.GetAll()

        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, permissions)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

type IRoleHandler interface {
        CreateRole(c *gin.Context)
        UpdateRole(c *gin.Context)
        GetRole(c *gin.Context)
        GetRoles(c *gin.Context)
        DeleteRole(c *gin.Context)
}

type RoleHandler struct {
        service services.IRoleService
}

func NewRoleHandler(service services.IRoleService) *RoleHandler <span class="cov8" title="1">{
        return &amp;RoleHandler{
                service: service,
        }
}</span>

func (handler *RoleHandler) CreateRole(ctx *gin.Context) <span class="cov8" title="1">{
        var input struct {
                Name        string `json:"name" binding:"required,min=3,max=255"`
                DisplayName string `json:"display_name" binding:"required,min=3,max=255"`
        }

        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                validateError := utils.TranslateValidationErrors(err, input)
                utils.RespondWithError(
                        ctx,
                        validateError,
                )
                return
        }</span>

        <span class="cov8" title="1">role := models.Role{
                Name:        input.Name,
                DisplayName: input.DisplayName,
        }

        if err := handler.service.Create(&amp;role); err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusCreated, gin.H{"message": "Create new role successfully"})</span>
}

func (handler *RoleHandler) UpdateRole(ctx *gin.Context) <span class="cov8" title="1">{
        var input struct {
                DisplayName string `json:"display_name" binding:"required,min=3,max=255"`
        }

        // Bind JSON request body to input struct
        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                validateError := utils.TranslateValidationErrors(err, input)
                utils.RespondWithError(ctx, validateError)
                return
        }</span>

        // Get role ID from URL parameter
        <span class="cov8" title="1">roleId := ctx.Param("id")
        // Convert role ID string to integer
        id, err := strconv.Atoi(roleId)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewParseError("Invalid RoleID"),
                )
                return
        }</span>

        // Get role from database by ID
        <span class="cov8" title="1">role, roleErr := handler.service.GetByID(int64(id))
        if roleErr != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, roleErr)
                return
        }</span>

        // Update role display name
        <span class="cov8" title="1">role.DisplayName = input.DisplayName

        // Save updated role to database
        if err := handler.service.Update(role); err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, gin.H{"message": "Update role successfully"})</span>
}

func (handler *RoleHandler) GetRole(ctx *gin.Context) <span class="cov8" title="1">{
        // Get role ID from URL parameter
        roleId := ctx.Param("id")
        // Convert role ID string to integer
        id, err := strconv.Atoi(roleId)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewParseError("Invalid RoleID"),
                )
                return
        }</span>

        // Get role from database by ID
        <span class="cov8" title="1">role, roleErr := handler.service.GetByID(int64(id))
        if roleErr != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, roleErr)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, role)</span>
}

func (handler *RoleHandler) DeleteRole(ctx *gin.Context) <span class="cov8" title="1">{
        // Get role ID from URL parameter
        roleId := ctx.Param("id")
        // Convert role ID string to integer
        id, err := strconv.Atoi(roleId)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewParseError("Invalid RoleID"),
                )
                return
        }</span>
        // Delete role from database
        <span class="cov8" title="1">if err := handler.service.Delete(int64(id)); err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>
        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, gin.H{"message": "Delete role successfully"})</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
)

type ISettingHandler interface {
        GetSettings(c *gin.Context)
        UpdateSettings(c *gin.Context)
}

type SettingHandler struct {
        service services.ISettingService
}

func NewSettingHandler(service services.ISettingService) *SettingHandler <span class="cov8" title="1">{
        return &amp;SettingHandler{service: service}
}</span>

func (handler *SettingHandler) GetSettings(c *gin.Context) <span class="cov8" title="1">{
        // Get settings from service
        settings, err := handler.service.GetSetting()
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(c, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(c, http.StatusOK, settings)</span>
}

func (handler *SettingHandler) UpdateSettings(ctx *gin.Context) <span class="cov8" title="1">{

        type KeyValue struct {
                Key   string `json:"key" binding:"required"`
                Value string `json:"value" binding:"required"`
        }
        type Settings struct {
                Settings []KeyValue `json:"settings" binding:"required,dive"`
        }

        var input Settings

        // Bind JSON request body to input struct
        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                validateError := utils.TranslateValidationErrors(err, input)
                utils.RespondWithError(ctx, validateError)
                return
        }</span>

        // Iterate through settings array from request
        <span class="cov8" title="1">for _, v := range input.Settings </span><span class="cov8" title="1">{
                // Get existing setting by key
                value, err := handler.service.GetSettingByKey(v.Key)
                if err != nil </span><span class="cov8" title="1">{
                        newSetting := models.Setting{
                                SettingKey: v.Key,
                                Value:      v.Value,
                        }

                        if err := handler.service.Create(&amp;newSetting); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Create new setting error for key:%s value:%s\n", v.Key, v.Value)
                                continue</span>
                        }
                } else<span class="cov8" title="1"> {
                        // Update setting value
                        value.Value = v.Value

                        // Save updated setting
                        if err := handler.service.Update(value); err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("Update setting error for key:%s value:%s\n", v.Key, v.Value)
                        }</span>
                }

        }

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, gin.H{"message": "Update setting successfully"})</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
        "github.com/vfa-khuongdv/golang-cms/internal/constants"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
)

type IUserhandler interface {
        PaginationUser(c *gin.Context)
        CreateUser(c *gin.Context)
        ForgotPassword(c *gin.Context)
        ResetPassword(c *gin.Context)
        Login(c *gin.Context)
        GetUser(c *gin.Context)
        GetUsers(c *gin.Context)
        UpdateUser(c *gin.Context)
        DeleteUser(c *gin.Context)
        GetProfile(c *gin.Context)
        UpdateProfile(c *gin.Context)
}

type UserHandler struct {
        userService   services.IUserService
        redisService  services.IRedisService
        bcryptService services.IBcryptService
}

func NewUserHandler(userService services.IUserService, redisService services.IRedisService, bcryptService services.IBcryptService) *UserHandler <span class="cov8" title="1">{
        return &amp;UserHandler{
                userService:   userService,
                redisService:  redisService,
                bcryptService: bcryptService,
        }
}</span>

func (handler *UserHandler) PaginationUser(c *gin.Context) <span class="cov8" title="1">{
        // Get the page and limit from the request context
        page, limit := utils.ParsePageAndLimit(c)
        // Call the userService to get the paginated list of users
        pagination, err := handler.userService.PaginateUser(page, limit)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(c, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(c, http.StatusOK, pagination)</span>
}

func (handler *UserHandler) CreateUser(ctx *gin.Context) <span class="cov8" title="1">{

        var input struct {
                Email    string  `json:"email" binding:"required,email"`
                Password string  `json:"password" binding:"required,min=6,max=255"`
                Name     string  `json:"name" binding:"required,min=1,max=45,not_blank"`     // Name must be between 1-45 chars and not blank
                Birthday *string `json:"birthday" binding:"required,valid_birthday"`         // Assumes birthday is valid format: YYYY-MM-DD
                Address  *string `json:"address" binding:"required,min=1,max=255,not_blank"` // Address must be between 1-255 chars and not blank
                Gender   int16   `json:"gender" binding:"required,oneof=1 2 3"`
                RoleIds  []uint  `json:"role_ids" binding:"required,min=1,dive,required"` // RoleIds must be a non-empty array of uints
        }

        // Bind and validate the JSON request body to the input struct
        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                validateError := utils.TranslateValidationErrors(err, input)
                utils.RespondWithError(ctx, validateError)
                return
        }</span>

        <span class="cov8" title="1">hashpassword, err := handler.bcryptService.HashPassword(input.Password)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewPasswordHashFailedError("Failed to hash password"))
                return
        }</span>

        // Create a new User model instance with the validated input data
        // Password is stored as the hashed value
        <span class="cov8" title="1">user := models.User{
                Name:     input.Name,
                Email:    input.Email,
                Password: hashpassword,
                Birthday: input.Birthday,
                Address:  input.Address,
                Gender:   input.Gender,
        }

        // Attempt to create the user in the database
        // Return 400 Bad Request if creation fails
        if err := handler.userService.CreateUser(&amp;user, input.RoleIds); err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusCreated, gin.H{"message": "Create user successfully"})</span>
}

func (handle *UserHandler) ForgotPassword(ctx *gin.Context) <span class="cov0" title="0">{
        var input struct {
                Email string `json:"email" binding:"required,email"`
        }
        // Bind and validate JSON request body
        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                validateError := utils.TranslateValidationErrors(err, input)
                utils.RespondWithError(ctx, validateError)
                return
        }</span>

        // Get user by email from database
        <span class="cov0" title="0">user, err := handle.userService.GetUserByEmail(input.Email)
        if err != nil </span><span class="cov0" title="0">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        // Generate random token string for password reset
        <span class="cov0" title="0">newToken := utils.GenerateRandomString(60)

        expiredAt := time.Now().Add(time.Hour).Unix()

        // Set new token on user
        user.Token = &amp;newToken
        user.ExpiredAt = &amp;expiredAt

        // Update user in database with new token
        if err := handle.userService.UpdateUser(user); err != nil </span><span class="cov0" title="0">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        // Send password reset email to user
        <span class="cov0" title="0">if err := services.SendMailForgotPassword(user); err != nil </span><span class="cov0" title="0">{
                utils.RespondWithError(ctx, err)
                return
        }</span>
        <span class="cov0" title="0">logger.Info("Email sent successfully!")

        utils.RespondWithOK(ctx, http.StatusOK, gin.H{"message": "Forgot password successfully"})</span>
}

func (handler *UserHandler) ResetPassword(ctx *gin.Context) <span class="cov8" title="1">{
        var input struct {
                Token       string `json:"token" binding:"required"`
                Password    string `json:"password" binding:"required,min=6,max=255"`
                NewPassword string `json:"new_password" binding:"required,min=6,max=255"`
        }
        // Bind and validate JSON request body
        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                validateError := utils.TranslateValidationErrors(err, input)
                utils.RespondWithError(ctx, validateError)
                return
        }</span>

        // Get user by token from database
        <span class="cov8" title="1">user, err := handler.userService.GetUserByToken(input.Token)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        // Check if token is expired
        <span class="cov8" title="1">if time.Now().Unix() &gt; *user.ExpiredAt </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, apperror.NewTokenExpiredError("Token is expired"))
                return
        }</span>

        // Check if new password is the same as old password
        <span class="cov8" title="1">if isValid := handler.bcryptService.CheckPasswordHash(input.Password, user.Password); !isValid </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, apperror.NewInvalidPasswordError("Old password is incorrect"))
                return
        }</span>

        // Hash the password using the utils.HashPassword function
        // If hashing fails (returns empty string), return a 400 error
        <span class="cov8" title="1">hashpassword, err := handler.bcryptService.HashPassword(input.Password)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, apperror.NewPasswordHashFailedError("Failed to hash password"))
                return
        }</span>

        // Update user password
        <span class="cov8" title="1">user.Password = hashpassword
        user.Token = nil
        user.ExpiredAt = nil

        // Update user in database
        if err := handler.userService.UpdateUser(user); err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, gin.H{"message": "Reset password successfully"})</span>
}

func (handler *UserHandler) ChangePassword(ctx *gin.Context) <span class="cov8" title="1">{
        // Get user ID from the context
        // If user ID is 0 or not found, return bad request error
        userId := ctx.GetUint("UserID")
        if userId == 0 </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewParseError("Invalid UserID"),
                )
                return
        }</span>

        <span class="cov8" title="1">var input struct {
                OldPassword     string `json:"old_password" binding:"required,min=6,max=255"`
                NewPassword     string `json:"new_password" binding:"required,min=6,max=255"`
                ConfirmPassword string `json:"confirm_password" binding:"required,min=6,max=255"`
        }
        // Bind and validate JSON request body
        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                validateError := utils.TranslateValidationErrors(err, input)
                utils.RespondWithError(ctx, validateError)
                return
        }</span>

        // Get user by ID from database
        <span class="cov8" title="1">user, err := handler.userService.GetUser(uint(userId))
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        // Check if old password is correct
        <span class="cov8" title="1">if isValid := handler.bcryptService.CheckPasswordHash(input.OldPassword, user.Password); !isValid </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewInvalidPasswordError("Old password is incorrect"),
                )
                return
        }</span>

        // Check if new password is the same as old password
        <span class="cov8" title="1">if input.OldPassword == input.NewPassword </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewPasswordMismatchError("New password must be different from old password"),
                )
                return
        }</span>

        // Check if new password and confirm password match
        <span class="cov8" title="1">if input.NewPassword != input.ConfirmPassword </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewPasswordMismatchError("New password and confirm password do not match"),
                )
                return
        }</span>

        // Hash the password using the utils.HashPassword function
        // If hashing fails (returns empty string), return a 500 error
        <span class="cov8" title="1">hashpassword, err := handler.bcryptService.HashPassword(input.NewPassword)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        // Update user password
        <span class="cov8" title="1">user.Password = hashpassword

        // Update user in database
        if err := handler.userService.UpdateUser(user); err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, gin.H{"message": "Change password successfully"})</span>
}

func (handler *UserHandler) DeleteUser(ctx *gin.Context) <span class="cov8" title="1">{
        // Get user ID from the context
        id := ctx.Param("id")
        userId, err := strconv.Atoi(id)

        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewParseError("Invalid UserID"),
                )
                return
        }</span>

        // Get user from database
        <span class="cov8" title="1">user, userErr := handler.userService.GetUser(uint(userId))
        if userErr != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, userErr)
                return
        }</span>

        // Delete user from database
        <span class="cov8" title="1">if err := handler.userService.DeleteUser(uint(user.ID)); err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, gin.H{"message": "Delete user successfully"})</span>
}

func (handler *UserHandler) UpdateUser(ctx *gin.Context) <span class="cov8" title="1">{
        // Get user ID from the context
        id := ctx.Param("id")
        userId, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewParseError("Invalid UserID"),
                )

                return
        }</span>

        // Define input struct with validation tags
        <span class="cov8" title="1">var input struct {
                Name     *string `json:"name" binding:"omitempty,min=1,max=45,not_blank"`     // Name must be between 1-45 chars and not blank
                Birthday *string `json:"birthday" binding:"omitempty,valid_birthday"`         // Assumes birthday is valid format: YYYY-MM-DD
                Address  *string `json:"address" binding:"omitempty,min=1,max=255,not_blank"` // Address must be between 1-255 chars and not blank
                Gender   *int16  `json:"gender" binding:"omitempty,oneof=1 2 3"`              // Gender must be one of [1 2 3]
        }

        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                validateError := utils.TranslateValidationErrors(err, input)
                utils.RespondWithError(ctx, validateError)
                return
        }</span>

        // Get existing user from database
        <span class="cov8" title="1">user, userErr := handler.userService.GetUser(uint(userId))
        // Return error if user not found
        if userErr != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, userErr)
                return
        }</span>

        // Update user fields with input values
        <span class="cov8" title="1">if input.Name != nil </span><span class="cov8" title="1">{
                user.Name = *input.Name
        }</span>
        <span class="cov8" title="1">if input.Birthday != nil </span><span class="cov8" title="1">{
                user.Birthday = input.Birthday
        }</span>
        <span class="cov8" title="1">if input.Address != nil </span><span class="cov8" title="1">{
                user.Address = input.Address
        }</span>
        <span class="cov8" title="1">if input.Gender != nil </span><span class="cov8" title="1">{
                user.Gender = *input.Gender
        }</span>

        // Save updated user to database
        <span class="cov8" title="1">if err := handler.userService.UpdateUser(user); err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, gin.H{"message": "Update user successfully"})</span>
}

func (handler *UserHandler) GetUser(ctx *gin.Context) <span class="cov8" title="1">{
        // Get user ID from the context
        id := ctx.Param("id")
        userId, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewParseError("Invalid UserID"),
                )
                return
        }</span>

        // Get user from database
        <span class="cov8" title="1">user, userErr := handler.userService.GetUser(uint(userId))
        if userErr != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, userErr)
                return
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, user)</span>
}

func (handler *UserHandler) GetProfile(ctx *gin.Context) <span class="cov8" title="1">{
        // Get user ID from the context
        userId := ctx.GetUint("UserID")
        if userId == 0 </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewParseError("Invalid UserID"),
                )
                return
        }</span>

        <span class="cov8" title="1">var user models.User

        // Try to get user from Redis cache
        cacheKey := constants.PROFILE + string(rune(userId))
        userString, err := handler.redisService.Get(cacheKey)
        if err != nil </span><span class="cov8" title="1">{
                logger.Warnf("Failed to get user from Redis: %+v", err)
        }</span>
        // If not in cache, get from DB
        <span class="cov8" title="1">if userString == "" </span><span class="cov8" title="1">{
                logger.Info("User retrieved from DB")
                dbUser, err := handler.userService.GetProfile(userId)
                if err != nil </span><span class="cov8" title="1">{
                        utils.RespondWithError(ctx, err)
                        return
                }</span>
                <span class="cov8" title="1">user = *dbUser

                // Cache the user data
                if err := handler.cacheUserProfile(&amp;user); err != nil </span><span class="cov8" title="1">{
                        logger.Warnf("Failed to cache user profile: %v", err)
                }</span>
        } else<span class="cov8" title="1"> {
                logger.Info("User retrieved from Redis")
                if err := json.Unmarshal([]byte(userString), &amp;user); err != nil </span><span class="cov8" title="1">{
                        logger.Warnf("Failed to unmarshal user from Redis: %v", err)
                        utils.RespondWithError(
                                ctx,
                                apperror.NewParseError("Invalid user data in cache"),
                        )
                        return
                }</span>

        }

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, user)</span>
}

// cacheUserProfile serializes a user object to JSON and stores it in Redis cache
// Parameters:
//   - user: pointer to the user model to be cached
//
// Returns:
//   - error if JSON marshaling or Redis caching fails
func (handler *UserHandler) cacheUserProfile(user *models.User) error <span class="cov8" title="1">{
        // Convert user object to JSON bytes
        userJSON, err := json.Marshal(user)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal user: %v", err)
        }</span>

        // Create Redis key by concatenating profile prefix with user ID
        <span class="cov8" title="1">profileKey := constants.PROFILE + string(rune(user.ID))

        // Store serialized user data in Redis
        if err := handler.redisService.Set(profileKey, userJSON, 60*time.Minute); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to cache in Redis: %v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (handler *UserHandler) UpdateProfile(ctx *gin.Context) <span class="cov8" title="1">{
        // Get user ID from context and validate
        userId := ctx.GetUint("UserID")
        if userId == 0 </span><span class="cov8" title="1">{
                utils.RespondWithError(
                        ctx,
                        apperror.NewParseError("Invalid UserID"),
                )
                return
        }</span>

        // Define input struct for profile update with validation rules
        <span class="cov8" title="1">var input struct {
                Name     *string `json:"name" binding:"omitempty,min=1,max=45,not_blank"`     // Name must be between 1 and 45 characters and not blank if provided
                Birthday *string `json:"birthday" binding:"omitempty,valid_birthday"`         // Birthday must be a valid date (YYYY-MM-DD) if provided
                Address  *string `json:"address" binding:"omitempty,min=1,max=255,not_blank"` // Address must be between 1 and 255 characters and not blank if provided
                Gender   *int16  `json:"gender" binding:"omitempty,oneof=1 2 3"`              // Gender must be 1, 2, or 3 if provided
        }

        // Bind and validate JSON request body
        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                validateError := utils.TranslateValidationErrors(err, input)
                utils.RespondWithError(ctx, validateError)
                return
        }</span>

        // Get existing user from database
        <span class="cov8" title="1">user, err := handler.userService.GetUser(userId)

        // Return error if user not found
        if err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>

        // Update user fields if provided in input
        <span class="cov8" title="1">if input.Name != nil </span><span class="cov8" title="1">{
                user.Name = *input.Name
        }</span>
        <span class="cov8" title="1">if input.Birthday != nil </span><span class="cov8" title="1">{
                user.Birthday = input.Birthday
        }</span>
        <span class="cov8" title="1">if input.Address != nil </span><span class="cov8" title="1">{
                user.Address = input.Address
        }</span>
        <span class="cov8" title="1">if input.Gender != nil </span><span class="cov8" title="1">{
                user.Gender = *input.Gender
        }</span>

        // Save updated user to database
        <span class="cov8" title="1">if err := handler.userService.UpdateUser(user); err != nil </span><span class="cov8" title="1">{
                utils.RespondWithError(ctx, err)
                return
        }</span>
        // Clear cache
        <span class="cov8" title="1">profileKey := constants.PROFILE + string(rune(user.ID))
        if err := handler.redisService.Delete(profileKey); err != nil </span><span class="cov8" title="1">{
                logrus.Errorf("Failed to clear cache: %v", err)
        }</span>

        <span class="cov8" title="1">utils.RespondWithOK(ctx, http.StatusOK, gin.H{"message": "Update profile successfully"})</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middlewares

import (
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

// AuthMiddleware is a Gin middleware function that handles JWT authentication
// It validates the Authorization header and extracts the JWT token
// The middleware checks if:
// - Authorization header exists and has "Bearer " prefix
// - Token is valid and can be parsed
// If validation succeeds, it sets the user ID from token claims in context
// If validation fails, it returns 401 Unauthorized
func AuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        jwtService := services.NewJWTService()
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{

                authHeader := ctx.GetHeader("Authorization")
                if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        utils.RespondWithError(ctx, apperror.NewUnauthorizedError("Authorization header required"))
                }</span>

                <span class="cov0" title="0">tokenString := strings.TrimPrefix(authHeader, "Bearer ")

                claims, err := jwtService.ValidateToken(tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        utils.RespondWithError(ctx, apperror.NewUnauthorizedError("Unauthorized"))
                }</span>

                <span class="cov0" title="0">ctx.Set("UserID", claims.ID)
                ctx.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package middlewares

import (
        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
)

// CORSMiddleware handles Cross-Origin Resource Sharing (CORS)
func CORSMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Get allowed origins from environment or use default
                allowedOrigins := utils.GetEnv("CORS_ALLOWED_ORIGINS", "*")

                c.Writer.Header().Set("Access-Control-Allow-Origin", allowedOrigins)
                c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, PATCH, DELETE")
                c.Writer.Header().Set("Access-Control-Max-Age", "86400") // 24 hours

                if c.Request.Method == "OPTIONS" </span><span class="cov8" title="1">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package middlewares

import (
        "bytes"
        "io"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

// Middleware to reject requests with empty JSON body
func EmptyBodyMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                if c.Request.Method == http.MethodPost || c.Request.Method == http.MethodPut || c.Request.Method == http.MethodPatch </span><span class="cov8" title="1">{
                        bodyBytes, err := io.ReadAll(c.Request.Body)
                        if err != nil || len(bytes.TrimSpace(bodyBytes)) == 0 </span><span class="cov8" title="1">{
                                c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
                                        "code":    apperror.ErrEmptyData,
                                        "message": "Request body cannot be empty",
                                })
                                return
                        }</span>
                        // Replace the body so the handler can read it again
                        <span class="cov8" title="1">c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))</span>
                }
                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middlewares

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
)

type LogResponse struct {
        Method     string `json:"method"`
        URL        string `json:"url"`
        Header     any    `json:"header"`
        Request    any    `json:"request,omitempty"`
        Response   any    `json:"response,omitempty"`
        Latency    string `json:"latency,omitempty"`
        StatusCode string `json:"status_code"`
}

// Middleware for logging requests and responses in Gin
func LogMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var requestBody any
                const maxBodySize = 1 &lt;&lt; 20 // Limit body size to 1 MB
                // Define sensitive keys to be masked in logs
                // These keys will be masked in both request and response logs
                sensitiveKeys := []string{
                        "password",
                        "api-key",
                        "token",
                        "access_token",
                        "refresh_token",
                        "ccv",
                        "credit_card",
                        "debit_card",
                        "social_security_number",
                        "ssn",
                        "bank_account",
                        "bank_account_number",
                        "email",
                        "phone",
                        "address",
                }

                timeStart := time.Now()

                var logEntry LogResponse
                logEntry.Method = c.Request.Method
                logEntry.URL = c.Request.URL.String()
                logEntry.Header = c.Request.Header
                logEntry.Request = c.Request.URL.Query()
                logEntry.Response = nil

                // Read and log request body
                if c.Request.Body != nil </span><span class="cov0" title="0">{
                        bodyBytes, _ := io.ReadAll(io.LimitReader(c.Request.Body, maxBodySize))
                        c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes)) // Restore body for the next handler

                        if strings.Contains(c.Request.Header.Get("Content-Type"), "application/json") </span><span class="cov0" title="0">{
                                if err := json.Unmarshal(bodyBytes, &amp;requestBody); err == nil </span><span class="cov0" title="0">{
                                        // Mask sensitive data in the request body
                                        requestBody = utils.CensorSensitiveData(requestBody, sensitiveKeys)
                                        // Store the masked data directly without converting to string
                                        logEntry.Request = requestBody
                                }</span> else<span class="cov0" title="0"> {
                                        logEntry.Request = string(bodyBytes)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                logEntry.Request = string(bodyBytes)
                        }</span>
                }

                // Create a buffer to capture the response body
                <span class="cov0" title="0">responseBody := &amp;bytes.Buffer{}
                c.Writer = &amp;bodyWriter{
                        ResponseWriter: c.Writer,
                        body:           responseBody,
                }

                // Process the request
                c.Next()

                timeEnd := time.Now()
                // Calculate latency
                logEntry.Latency = fmt.Sprintf("%d (ms)", timeEnd.Sub(timeStart).Milliseconds())

                // Log response
                var responseBodyData any
                if strings.Contains(c.Writer.Header().Get("Content-Type"), "application/json") </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(responseBody.Bytes(), &amp;responseBodyData); err == nil </span><span class="cov0" title="0">{
                                // Mask sensitive data in the response body
                                responseBodyData = utils.CensorSensitiveData(responseBodyData, sensitiveKeys)
                                // Store the masked data directly
                                logEntry.Response = responseBodyData
                        }</span> else<span class="cov0" title="0"> {
                                logEntry.Response = responseBody.String()
                        }</span>
                } else<span class="cov0" title="0"> {
                        logEntry.Response = responseBody.String()
                }</span>

                <span class="cov0" title="0">logEntry.StatusCode = fmt.Sprintf("%d", c.Writer.Status())

                jsonData, err := json.Marshal(logEntry)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to marshal log entry:", err)
                        return
                }</span>
                <span class="cov0" title="0">logger.Info(string(jsonData))</span>
        }
}

// bodyWriter is a custom ResponseWriter to capture the response body
type bodyWriter struct {
        gin.ResponseWriter
        body *bytes.Buffer
}

func (w *bodyWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        w.body.Write(b)
        return w.ResponseWriter.Write(b)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package repositories

import (
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "gorm.io/gorm"
)

type IPermissionRepository interface {
        Create(item *models.Permission) error
        GetAll() ([]models.Permission, error)
}

type PermissionRepository struct {
        db *gorm.DB
}

func NewPermissionRepository(db *gorm.DB) *PermissionRepository <span class="cov8" title="1">{
        return &amp;PermissionRepository{db: db}
}</span>

// GetAll retrieves all permission records from the database
// Returns:
//   - *[]models.Permission: pointer to slice containing all permissions
//   - error: nil if successful, error if the database operation fails
func (repo *PermissionRepository) GetAll() ([]models.Permission, error) <span class="cov8" title="1">{
        var permissions []models.Permission

        if err := repo.db.Find(&amp;permissions).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return permissions, nil</span>
}

// Create adds a new permission record to the database
// Parameters:
//   - item: pointer to the Permission model to be created
//
// Returns:
//   - error: nil if successful, error if the database operation fails
func (repo *PermissionRepository) Create(item *models.Permission) error <span class="cov8" title="1">{
        return repo.db.Create(item).Error
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package repositories

import (
        "time"

        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "gorm.io/gorm"
)

type IRefreshTokenRepository interface {
        Create(token *models.RefreshToken) error
        Update(token *models.RefreshToken) error
        FindByToken(token string) (*models.RefreshToken, error)
        First(token string) (*models.RefreshToken, error)
}

type RefreshTokenRepository struct {
        db *gorm.DB
}

// NewRefreshTokenRepository creates a new instance of RefreshTokenRepository
// Parameters:
//   - db: pointer to the gorm.DB instance for database operations
//
// Returns:
//   - *RefreshTokenRepository: pointer to the newly created RefreshTokenRepository
func NewRefreshTokenRepository(db *gorm.DB) *RefreshTokenRepository <span class="cov8" title="1">{
        return &amp;RefreshTokenRepository{db: db}
}</span>

// Create creates a new refresh token in the database
// Parameters:
//   - token: pointer to the RefreshToken model to be saved
//
// Returns:
//   - error: nil if successful, error otherwise
func (repo *RefreshTokenRepository) Create(token *models.RefreshToken) error <span class="cov8" title="1">{
        return repo.db.Create(token).Error
}</span>

// First retrieves the first refresh token from the database by its token value
// Parameters:
//   - token: string representing the refresh token to search for
//
// Returns:
//   - *models.RefreshToken: pointer to the found RefreshToken model, nil if not found
//   - error: nil if successful, error otherwise
func (repo *RefreshTokenRepository) First(token string) (*models.RefreshToken, error) <span class="cov8" title="1">{
        var refreshToken models.RefreshToken
        if err := repo.db.Where("refresh_token = ?", token).First(&amp;refreshToken).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;refreshToken, nil</span>
}

// FindByToken retrieves a refresh token from the database by its token value
// Parameters:
//   - token: string representing the refresh token to search for
//
// Returns:
//   - *models.RefreshToken: pointer to the found RefreshToken model, nil if not found
//   - error: nil if successful, error otherwise
func (repo *RefreshTokenRepository) FindByToken(token string) (*models.RefreshToken, error) <span class="cov8" title="1">{
        var refreshToken models.RefreshToken
        if err := repo.db.Where("refresh_token = ? and expired_at &gt; ?", token, time.Now().Unix()).First(&amp;refreshToken).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;refreshToken, nil</span>
}

// Update updates an existing refresh token in the database
// Parameters:
//   - token: pointer to the RefreshToken model to be updated
//
// Returns:
//   - error: nil if successful, error otherwise
func (repo *RefreshTokenRepository) Update(token *models.RefreshToken) error <span class="cov8" title="1">{
        return repo.db.Save(token).Error
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package repositories

import (
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "gorm.io/gorm"
)

type IRoleRepository interface {
        GetByID(id int64) (*models.Role, error)
        Create(role *models.Role) error
        Update(role *models.Role) error
        Delete(role *models.Role) error
}

type RoleRepository struct {
        db *gorm.DB
}

func NewRoleRepository(db *gorm.DB) *RoleRepository <span class="cov8" title="1">{
        return &amp;RoleRepository{db: db}
}</span>

// GetByID retrieves a role by its ID from the database
// Parameters:
//   - id: The unique identifier of the role to retrieve
//
// Returns:
//   - *models.Role: Pointer to the retrieved role if found
//   - error: nil if successful, error message if failed
func (repo *RoleRepository) GetByID(id int64) (*models.Role, error) <span class="cov8" title="1">{
        var role models.Role
        if err := repo.db.Preload("Permissions").First(&amp;role, id).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;role, nil</span>
}

// Create inserts a new role record into the database
// Parameters:
//   - role: Pointer to the role model to be created
//
// Returns:
//   - error: nil if successful, error message if failed
func (repo *RoleRepository) Create(role *models.Role) error <span class="cov8" title="1">{
        return repo.db.Create(role).Error
}</span>

// Update modifies an existing role record in the database
// Parameters:
//   - role: Pointer to the role model containing updated data
//
// Returns:
//   - error: nil if successful, error message if failed
func (repo *RoleRepository) Update(role *models.Role) error <span class="cov8" title="1">{
        return repo.db.Save(role).Error
}</span>

// Delete removes a role record from the database
// Parameters:
//   - role: Pointer to the role model to be deleted
//
// Returns:
//   - error: nil if successful, error message if failed
func (repo *RoleRepository) Delete(role *models.Role) error <span class="cov8" title="1">{
        return repo.db.Delete(role).Error
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package repositories

import (
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "gorm.io/gorm"
)

type ISettingRepository interface {
        GetAll() ([]models.Setting, error) // We return a slice of Setting models not a pointer to a slice because we don't need to modify the slice itself, just the elements inside it
        GetByKey(key string) (*models.Setting, error)
        Update(setting *models.Setting) error
        Create(setting *models.Setting) error
}

type SettingRepository struct {
        db *gorm.DB
}

func NewSettingRepository(db *gorm.DB) *SettingRepository <span class="cov8" title="1">{
        return &amp;SettingRepository{db: db}
}</span>

// GetAll retrieves all settings from the database
// Parameters:
//   - None
//
// Returns:
//   - []models.Setting: Pointer to slice of Setting models containing all settings
//   - error: Error if database operation fails, nil otherwise
func (repo *SettingRepository) GetAll() ([]models.Setting, error) <span class="cov8" title="1">{
        var settings []models.Setting

        if err := repo.db.Find(&amp;settings).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return settings, nil</span>

}

// GetByKey retrieves a setting by its key from the database
// Parameters:
//   - key: string - The key to search for
//
// Returns:
//   - *models.Setting: Pointer to Setting model if found, nil if not found
//   - error: Error if database operation fails, nil otherwise
func (repo *SettingRepository) GetByKey(key string) (*models.Setting, error) <span class="cov8" title="1">{
        var setting models.Setting

        if err := repo.db.Model(&amp;models.Setting{}).Where("setting_key = ?", key).First(&amp;setting).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;setting, nil</span>
}

// Update saves a setting to the database
// Parameters:
//   - setting: *models.Setting - Pointer to Setting model to be updated
//
// Returns:
//   - *models.Setting: Pointer to updated Setting model
//   - error: Error if database operation fails, nil otherwise
func (repo *SettingRepository) Update(setting *models.Setting) error <span class="cov8" title="1">{
        return repo.db.Save(setting).Error
}</span>

// Create saves a new setting to the database
// Parameters:
//   - setting: *models.Setting - Pointer to Setting model to be created
//
// Returns:
//   - *models.Setting: Pointer to created Setting model
//   - error: Error if database operation fails, nil otherwise
func (repo *SettingRepository) Create(setting *models.Setting) error <span class="cov8" title="1">{
        return repo.db.Create(setting).Error
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package repositories

import (
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "gorm.io/gorm"
)

type IUserRepository interface {
        PaginateUser(page, limit int) (*utils.Pagination, error)
        GetAll() ([]models.User, error)
        GetByID(id uint) (*models.User, error)
        Create(user *models.User) (*models.User, error)
        CreateWithTx(tx *gorm.DB, user *models.User) (*models.User, error)
        Update(user *models.User) error
        Delete(userId uint) error
        FindByField(field string, value string) (*models.User, error)
        GetProfile(id uint) (*models.User, error)
        UpdateProfile(user *models.User) error
        GetUserPermissions(userID uint) ([]models.Permission, error)
        GetDB() *gorm.DB
}

type UserRepository struct {
        db *gorm.DB
}

func NewUserRepository(db *gorm.DB) *UserRepository <span class="cov8" title="1">{
        return &amp;UserRepository{db: db}
}</span>

// PaginateUser retrieves a paginated list of users from the database
// Parameters:
//   - page: The page number to retrieve (default is 1)
//   - limit: The number of users per page (default is 10)
//
// Returns:
//   - *utils.Pagination: A pointer to the pagination object containing user data
//   - error: nil if successful, otherwise returns the error that occurred
//
// Example:
//   - users, err := repo.PaginateUser(1, 50) // Gets the first page of users
func (repo *UserRepository) PaginateUser(page, limit int) (*utils.Pagination, error) <span class="cov8" title="1">{
        var totalRows int64
        offset := (page - 1) * limit

        // Count total rows
        if err := repo.db.Model(&amp;models.User{}).Count(&amp;totalRows).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var users []models.User
        // fetch paginated data
        if err := repo.db.Offset(offset).Limit(limit).Order("id DESC").Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">pagination := &amp;utils.Pagination{
                Page:       page,
                Limit:      limit,
                TotalItems: int(totalRows),
                TotalPages: utils.CalculateTotalPages(totalRows, limit),
                Data:       users,
        }
        return pagination, nil</span>
}

// GetAll retrieves all users from the database
// Parameters:
//   - None
//
// Returns:
//   - []models.User: Slice containing all User models in the database
//   - error: Error if there was a database error, nil on success
func (repo *UserRepository) GetAll() ([]models.User, error) <span class="cov8" title="1">{
        var users []models.User
        if err := repo.db.Find(&amp;users).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return users, nil</span>
}

// GetByID retrieves a user from the database by their ID
// Parameters:
//   - id: The unique identifier of the user to retrieve
//
// Returns:
//   - *models.User: Pointer to the retrieved User model
//   - error: Error if the user is not found or if there was a database error
func (repo *UserRepository) GetByID(id uint) (*models.User, error) <span class="cov8" title="1">{
        var user models.User
        if err := repo.db.Preload("Roles.Permissions").First(&amp;user, id).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

// Create creates a new user in the database
// Parameters:
//   - user: Pointer to the User model to be created
//
// Returns:
//   - *models.User: Pointer to the created User model with assigned ID
//   - error: Error if there was a problem creating the user, nil on success
func (repo *UserRepository) Create(user *models.User) (*models.User, error) <span class="cov8" title="1">{
        if err := repo.db.Create(user).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// CreateWithTx creates a new user in the database within a transaction
// Parameters:
//   - tx: Pointer to the gorm.DB transaction
//   - user: Pointer to the User model to be created
//
// Returns:
//   - *models.User: Pointer to the created User model with assigned ID
//   - error: Error if there was a problem creating the user, nil on success
func (repo *UserRepository) CreateWithTx(tx *gorm.DB, user *models.User) (*models.User, error) <span class="cov8" title="1">{
        if err := tx.Create(user).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// Update updates an existing user in the database
// Parameters:
//   - user: Pointer to the User model to be updated
//
// Returns:
//   - error: Error if there was a problem updating the user, nil on success
func (repo *UserRepository) Update(user *models.User) error <span class="cov8" title="1">{
        return repo.db.Save(user).Error
}</span>

// Delete removes a user from the database
// Parameters:
//   - id: userId to be deleted
//
// Returns:
//   - error: Error if there was a problem deleting the user, nil on success
func (repo *UserRepository) Delete(userId uint) error <span class="cov8" title="1">{
        var user models.User
        return repo.db.Delete(&amp;user, userId).Error
}</span>

// FindByField retrieves a user from the database by a specified field and value
// Parameters:
//   - field: The field to search by (e.g., "name", "email", "token")
//   - value: The value to match against the specified field
//
// Returns:
//   - *models.User: Pointer to the retrieved User model if found
//   - error: Error if user not found or if there was a database error
func (repo *UserRepository) FindByField(field string, value string) (*models.User, error) <span class="cov8" title="1">{
        // Validate field input to prevent SQL injection
        switch field </span>{
        case "name":<span class="cov8" title="1">
                field = "name"</span>
        case "email":<span class="cov8" title="1">
                field = "email"</span>
        case "token":<span class="cov8" title="1">
                field = "token"</span>
        default:<span class="cov8" title="1">
                return nil, gorm.ErrInvalidField</span>
        }

        <span class="cov8" title="1">var user models.User
        if err := repo.db.Where(field+" = ?", value).First(&amp;user).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

// GetProfile retrieves a user's profile from the database by their ID
// Parameters:
//   - id: The unique identifier of the user whose profile is to be retrieved
//
// Returns:
//   - *models.User: Pointer to the retrieved User model containing profile information
//   - error: Error if the profile is not found or if there was a database error
func (repo *UserRepository) GetProfile(id uint) (*models.User, error) <span class="cov8" title="1">{
        var user models.User
        if err := repo.db.Preload("Roles").First(&amp;user, id).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

// UpdateProfile updates a user's profile information in the database
// Parameters:
//   - user: Pointer to the User model containing updated profile information
//
// Returns:
//   - error: Error if there was a problem updating the profile, nil on success
func (repo *UserRepository) UpdateProfile(user *models.User) error <span class="cov8" title="1">{
        return repo.db.Save(&amp;user).Error
}</span>

// GetUserPermission retrieves all permission associated with a specific user ID
// Parameters:
//   - userID: The unique identifier of the user whose roles are to be retrieved
//
// Returns:
//   - []string: Slice containing all permission assigned to the user
//   - error: Error if there was a database error, nil on success
func (repo *UserRepository) GetUserPermissions(userID uint) ([]models.Permission, error) <span class="cov8" title="1">{
        var user models.User
        if err := repo.db.Preload("Roles.Permissions").First(&amp;user, userID).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var permissions []models.Permission
        for _, role := range user.Roles </span><span class="cov8" title="1">{
                permissions = append(permissions, role.Permissions...)
        }</span>
        <span class="cov8" title="1">return permissions, nil</span>
}

// GetDB returns the database connection
// Used for transaction handling and other direct database operations
//
// Returns:
//   - *gorm.DB: The database connection
func (repo *UserRepository) GetDB() *gorm.DB <span class="cov8" title="1">{
        return repo.db
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package routes

import (
        "github.com/gin-gonic/gin"
        "github.com/redis/go-redis/v9"
        "github.com/vfa-khuongdv/golang-cms/internal/guards"
        "github.com/vfa-khuongdv/golang-cms/internal/handlers"
        "github.com/vfa-khuongdv/golang-cms/internal/middlewares"
        "github.com/vfa-khuongdv/golang-cms/internal/repositories"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "gorm.io/gorm"
)

func SetupRouter(db *gorm.DB) *gin.Engine <span class="cov0" title="0">{
        // Set Gin mode from environment variable
        ginMode := utils.GetEnv("GIN_MODE", "debug")
        gin.SetMode(ginMode)

        // Initialize the new Gin router
        router := gin.New()

        stage := utils.GetEnv("STAGE", "dev")

        // Set up Swagger documentation only in non-production environments
        if stage != "prod" </span><span class="cov0" title="0">{
                router.StaticFile("/docs/swagger.json", "./docs/swagger.json")
                router.StaticFile("/swagger", "./docs/swagger.html")
                router.StaticFile("/api-docs", "./docs/swagger.html")
        }</span>

        // Initialize repositories
        <span class="cov0" title="0">userRepo := repositories.NewUserRepository(db)
        refreshRepo := repositories.NewRefreshTokenRepository(db)
        roleRepo := repositories.NewRoleRepository(db)
        settingRepo := repositories.NewSettingRepository(db)
        permissionRepo := repositories.NewPermissionRepository(db)

        // Initialize services
        client := redis.NewClient(&amp;redis.Options{
                Addr:     utils.GetEnv("REDIS_HOST", "localhost:6379"),
                Password: utils.GetEnv("REDIS_PASS", ""),
                DB:       utils.GetEnvAsInt("REDIS_DB", 0),
        })

        redisService := services.NewRedisService(client)
        refreshTokenService := services.NewRefreshTokenService(refreshRepo)
        userService := services.NewUserService(userRepo)
        bcryptService := services.NewBcryptService()
        jwtService := services.NewJWTService()
        authService := services.NewAuthService(userRepo, refreshTokenService, bcryptService, jwtService)
        roleService := services.NewRoleService(roleRepo)
        settingService := services.NewSettingService(settingRepo)
        permissionService := services.NewPermissionService(permissionRepo)

        // Initialize role guard for permission checks
        roleGuard := guards.NewRoleGuard(db)

        // Initialize handlers
        authHandler := handlers.NewAuthHandler(authService)
        userHandler := handlers.NewUserHandler(userService, redisService, bcryptService)
        roleHandler := handlers.NewRoleHandler(roleService)
        settingHandler := handlers.NewSettingHandler(settingService)
        permissionHandler := handlers.NewPermissionHandler(permissionService)

        // Add middleware for CORS and logging
        router.Use(
                middlewares.CORSMiddleware(),
                middlewares.LogMiddleware(),
                gin.Recovery(),
                middlewares.EmptyBodyMiddleware(),
        )

        router.GET("/healthz", handlers.HealthCheck)

        // Setup API routes
        api := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Public routes
                api.POST("/login", authHandler.Login)
                api.POST("/refresh-token", authHandler.RefreshToken)
                api.POST("/forgot-password", userHandler.ForgotPassword)
                api.POST("/reset-password", userHandler.ResetPassword)

                // Protected routes (require authentication)
                authenticated := api.Group("/")
                authenticated.Use(middlewares.AuthMiddleware())
                </span><span class="cov0" title="0">{
                        // Profile management (available to all authenticated users)
                        authenticated.POST("/change-password", userHandler.ChangePassword)
                        authenticated.GET("/profile", userHandler.GetProfile)
                        authenticated.PATCH("/profile", userHandler.UpdateProfile)

                        // User management routes with permission checks
                        authenticated.GET("/users", guards.RequirePermissions(roleGuard, "users:view"), userHandler.PaginationUser)
                        authenticated.POST("/users", guards.RequirePermissions(roleGuard, "users:create"), userHandler.CreateUser)
                        authenticated.GET("/users/:id", guards.RequirePermissions(roleGuard, "users:view"), userHandler.GetUser)
                        authenticated.PATCH("/users/:id", guards.RequirePermissions(roleGuard, "users:update"), userHandler.UpdateUser)
                        authenticated.DELETE("/users/:id", guards.RequirePermissions(roleGuard, "users:delete"), userHandler.DeleteUser)

                        // Role management routes with permission checks
                        authenticated.POST("/roles", guards.RequirePermissions(roleGuard, "roles:create"), roleHandler.CreateRole)
                        authenticated.GET("/roles/:id", guards.RequirePermissions(roleGuard, "roles:view"), roleHandler.GetRole)
                        authenticated.PATCH("/roles/:id", guards.RequirePermissions(roleGuard, "roles:update"), roleHandler.UpdateRole)
                        authenticated.DELETE("/roles/:id", guards.RequirePermissions(roleGuard, "roles:delete"), roleHandler.DeleteRole)

                        // Settings with permission checks
                        authenticated.GET("/settings", guards.RequirePermissions(roleGuard, "settings:view"), settingHandler.GetSettings)
                        authenticated.PATCH("/settings", guards.RequirePermissions(roleGuard, "settings:update"), settingHandler.UpdateSettings)

                        // Permissions with permission checks
                        authenticated.GET("/permissions", guards.RequirePermissions(roleGuard, "roles:view"), permissionHandler.GetAll)
                }</span>
        }

        <span class="cov0" title="0">return router</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package services

import (
        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/repositories"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

type IAuthService interface {
        Login(email, password string, ctx *gin.Context) (*LoginResponse, error)
        RefreshToken(token string, ctx *gin.Context) (*LoginResponse, error)
}

type AuthService struct {
        repo                repositories.IUserRepository
        refreshTokenService IRefreshTokenService
        bcryptService       IBcryptService
        jwtService          IJWTService
}

type LoginResponse struct {
        AccessToken  JwtResult `json:"accessToken"`
        RefreshToken JwtResult `json:"refreshToken"`
}

// NewAuthService creates and returns a new instance of AuthService
// Parameters:
//   - repo: User repository for database operations
//   - tokenService: Service for handling refresh token operations
//
// Returns:
//   - *AuthService: New AuthService instance initialized with the provided dependencies
func NewAuthService(repo repositories.IUserRepository, refreshTokenService IRefreshTokenService, bcryptService IBcryptService, jwtService IJWTService) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                repo:                repo,
                refreshTokenService: refreshTokenService,
                bcryptService:       bcryptService,
                jwtService:          jwtService,
        }
}</span>

// Login authenticates a user with their username and password
// Parameters:
//   - username: The username of the user trying to log in
//   - password: The password provided by the user
//   - ctx: Gin context containing request information
//
// Returns:
//   - *LoginResponse: Contains access token and refresh token if login successful
//   - error: Returns error if login fails (user not found, invalid password, token generation fails)
func (service *AuthService) Login(email, password string, ctx *gin.Context) (*LoginResponse, error) <span class="cov8" title="1">{
        user, err := service.repo.FindByField("email", email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewNotFoundError(err.Error())
        }</span>

        // Validate password
        <span class="cov8" title="1">if isValid := service.bcryptService.CheckPasswordHash(password, user.Password); !isValid </span><span class="cov8" title="1">{
                return nil, apperror.NewInvalidPasswordError("Invalid credentials")
        }</span>

        // Generate access token
        <span class="cov8" title="1">accessToken, err := service.jwtService.GenerateToken(user.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewInternalError(err.Error())
        }</span>

        // Create new refresh token
        <span class="cov8" title="1">ipAddress := ctx.ClientIP()
        refreshToken, errToken := service.refreshTokenService.Create(user, ipAddress)

        if errToken != nil </span><span class="cov8" title="1">{
                return nil, errToken
        }</span>

        <span class="cov8" title="1">res := &amp;LoginResponse{
                AccessToken: JwtResult{
                        Token:     accessToken.Token,
                        ExpiresAt: accessToken.ExpiresAt,
                },
                RefreshToken: JwtResult{
                        Token:     refreshToken.Token,
                        ExpiresAt: refreshToken.ExpiresAt,
                },
        }

        return res, nil</span>
}

// RefreshToken generates new access and refresh tokens using an existing refresh token
// Parameters:
//   - token: The existing refresh token string
//   - ctx: Gin context containing request information
//
// Returns:
//   - *LoginResponse: Contains new access token and refresh token if successful
//   - error: Returns error if token refresh fails (invalid token, user not found, token generation fails)
func (service *AuthService) RefreshToken(token string, ctx *gin.Context) (*LoginResponse, error) <span class="cov8" title="1">{
        ipAddress := ctx.ClientIP()

        // Update the refresh token
        refreshResult, err := service.refreshTokenService.Update(token, ipAddress)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewDBUpdateError(err.Error())
        }</span>

        // Get user details
        <span class="cov8" title="1">user, err := service.repo.GetByID(refreshResult.UserId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewNotFoundError(err.Error())
        }</span>

        // Generate new access token
        <span class="cov8" title="1">newToken, err := service.jwtService.GenerateToken(user.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewInternalError(err.Error())
        }</span>

        // Build response
        <span class="cov8" title="1">response := &amp;LoginResponse{
                AccessToken: JwtResult{
                        Token:     newToken.Token,
                        ExpiresAt: newToken.ExpiresAt,
                },
                RefreshToken: *refreshResult.Token,
        }

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package services

import (
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
        "golang.org/x/crypto/bcrypt"
)

type IBcryptService interface {
        HashPassword(password string) (string, error)
        CheckPasswordHash(password, hashPassword string) bool
        HashPasswordWithCost(password string, cost int) (string, error)
}

type BcryptService struct{}

func NewBcryptService() IBcryptService <span class="cov8" title="1">{
        return &amp;BcryptService{}
}</span>

// HashPassword hashes a password using bcrypt with the default cost
// Returns the hashed password as a string, or an error if hashing fails
func (s *BcryptService) HashPassword(password string) (string, error) <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperror.NewInternalError(err.Error())
        }</span>
        <span class="cov8" title="1">return string(hashedPassword), nil</span>
}

// CheckPasswordHash compares a plain text password with a hashed password
// Returns true if they match, false otherwise
func (s *BcryptService) CheckPasswordHash(password, hashPassword string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hashPassword), []byte(password))
        return err == nil
}</span>

// HashPasswordWithCost hashes a password using bcrypt with a specified cost
// Returns the hashed password as a string, or an error if hashing fails
func (s *BcryptService) HashPasswordWithCost(password string, cost int) (string, error) <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), cost)
        if err != nil </span><span class="cov8" title="1">{
                return "", apperror.NewInternalError(err.Error())
        }</span>
        <span class="cov8" title="1">return string(hashedPassword), nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package services

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
)

// CustomClaims represents JWT claims with a custom user ID field
type CustomClaims struct {
        ID uint `json:"id"`
        jwt.RegisteredClaims
}

// JwtResult represents the result of a token generation
type JwtResult struct {
        Token     string `json:"token"`
        ExpiresAt int64  `json:"expiresAt"`
}

// IJWTService defines JWT-related operations
type IJWTService interface {
        GenerateToken(id uint) (*JwtResult, error)
        ValidateToken(tokenString string) (*CustomClaims, error)
}

// jwtService implements JWTService
type jwtService struct {
        secret []byte
}

// NewJWTService returns a new instance of jwtService
func NewJWTService() IJWTService <span class="cov8" title="1">{
        secret := []byte(utils.GetEnv("JWT_KEY", "replace_your_key"))
        return &amp;jwtService{
                secret: secret,
        }
}</span>

// GenerateToken creates a new JWT token for the given user ID
func (s *jwtService) GenerateToken(id uint) (*JwtResult, error) <span class="cov8" title="1">{
        expiresAt := jwt.NewNumericDate(time.Now().Add(time.Hour))
        claims := CustomClaims{
                ID: id,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: expiresAt,
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        signedToken, err := token.SignedString(s.secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;JwtResult{
                Token:     signedToken,
                ExpiresAt: expiresAt.Unix(),
        }, nil</span>
}

// ValidateToken validates a JWT token string and returns the claims if valid
func (s *jwtService) ValidateToken(tokenString string) (*CustomClaims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;CustomClaims{}, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return s.secret, nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if claims, ok := token.Claims.(*CustomClaims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, err</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        "bytes"
        "fmt"
        "html/template"

        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
        "github.com/vfa-khuongdv/golang-cms/pkg/mailer"
)

type IMailerService interface {
        SendMailForgotPassword(user *models.User) error
}

// SendMailForgotPassword sends a password reset email to the user
// Parameters:
//   - user: Pointer to models.User containing user information including email and reset token
//
// Returns:
//   - error: Returns nil on success, error on failure
//
// The function:
//  1. Creates SMTP config from environment variables
//  2. Initializes mail sender
//  3. Parses email template
//  4. Executes template with user data
//  5. Sends password reset email to user
func SendMailForgotPassword(user *models.User) error <span class="cov0" title="0">{

        var config = mailer.GomailSenderConfig{
                Host:     utils.GetEnv("MAIL_HOST", "smtp.gmail.com"),
                Port:     utils.GetEnvAsInt("MAIL_PORT", 587),
                Username: utils.GetEnv("MAIL_USERNAME", ""),
                Password: utils.GetEnv("MAIL_PASSWORD", ""),
                From:     utils.GetEnv("MAIL_FROM", ""),
        }

        mailer := mailer.NewGomailSender(mailer.GomailSenderConfig{
                From:     config.From,
                Host:     config.Host,
                Port:     config.Port,
                Username: config.Username,
                Password: config.Password,
        })

        // Parse the email template file
        tmpl, err := template.ParseFiles("pkg/mailer/templates/forgot_template.html")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error parsing template: %w", err)
        }</span>

        // Construct reset password URL by combining frontend URL with user's reset token
        <span class="cov0" title="0">url := utils.GetEnv("FRONTEND_URL", "") + "/reset-password?token=" + *user.Token

        // Prepare template data with user's name and reset URL
        data := map[string]interface{}{
                "Name": user.Name,
                "URL":  url,
        }
        // Create buffer to store rendered HTML
        var htmlBody bytes.Buffer
        // Execute template with data and write to buffer
        if err := tmpl.Execute(&amp;htmlBody, data); err != nil </span><span class="cov0" title="0">{
                return apperror.NewInternalError(fmt.Sprintf("error executing template: %+v", err))
        }</span>
        // Send password reset email to user
        <span class="cov0" title="0">if err := mailer.Send([]string{user.Email}, "Reset your password", "", htmlBody.String()); err != nil </span><span class="cov0" title="0">{
                return apperror.NewInternalError(fmt.Sprintf("error sending email: %+v", err))
        }</span>
        <span class="cov0" title="0">return nil</span>

}
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/repositories"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

type IPermissionService interface {
        GetAll() ([]models.Permission, error)
}

type PermissionService struct {
        repo repositories.IPermissionRepository
}

func NewPermissionService(repo repositories.IPermissionRepository) *PermissionService <span class="cov8" title="1">{
        return &amp;PermissionService{
                repo: repo,
        }
}</span>

// GetAll retrieves all permissions from the repository
// Returns:
//   - *[]models.Permission: Pointer to slice of Permission models containing all permissions
//   - error: Error if any occurred during the operation
func (repo *PermissionService) GetAll() ([]models.Permission, error) <span class="cov8" title="1">{
        permission, err := repo.repo.GetAll()
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewInternalError(err.Error())
        }</span>
        <span class="cov8" title="1">return permission, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
        "github.com/vfa-khuongdv/golang-cms/pkg/logger"
        "golang.org/x/net/context"
)

type IRedisService interface {
        Set(key string, value any, ttl time.Duration) error
        Get(key string) (string, error)
        Delete(key string) error
        Exists(key string) (bool, error)
}

type RedisService struct {
        client redis.Cmdable
        ctx    context.Context
}

// NewRedisService creates and initializes a new Redis service connection
//
// Returns:
//   - *RedisService: Pointer to initialized Redis service
//   - Panics if connection fails
func NewRedisService(client redis.Cmdable) *RedisService <span class="cov8" title="1">{
        ctx := context.Background()
        _, err := client.Ping(ctx).Result()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        } else<span class="cov8" title="1"> {
                logger.Info("Connected to Redis successfully")
        }</span>

        <span class="cov8" title="1">return &amp;RedisService{
                client: client,
                ctx:    context.Background(),
        }</span>
}

// Set stores a key-value pair in Redis with no expiration time
// Parameters:
//   - key: the key to store the value under
//   - value: the value to store (can be any type that Redis supports)
//
// Returns:
//   - *appError.AppError: nil if successful, otherwise contains the error message
func (r *RedisService) Set(key string, value any, ttl time.Duration) error <span class="cov8" title="1">{
        err := r.client.Set(r.ctx, key, value, ttl).Err()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.NewCacheSetError(err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Get retrieves a value from Redis by its key
// Parameters:
//   - key: the key to look up in Redis
//
// Returns:
//   - string: the value stored at the key, or empty string if key doesn't exist
//   - error: nil if successful or key not found, otherwise contains error message
func (r *RedisService) Get(key string) (string, error) <span class="cov8" title="1">{
        val, err := r.client.Get(r.ctx, key).Result()

        if err == redis.Nil </span><span class="cov8" title="1">{
                return "", nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return "", apperror.NewCacheGetError(err.Error())
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}

// Delete removes a key-value pair from Redis
// Parameters:
//   - key: the key to delete from Redis
//
// Returns:
//   - error: nil if successful, otherwise contains the error message
func (r *RedisService) Delete(key string) error <span class="cov8" title="1">{
        err := r.client.Del(r.ctx, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.NewCacheDeleteError(err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Exists checks if a key exists in Redis
// Parameters:
//   - key: the key to check in Redis
//
// Returns:
//   - bool: true if key exists, false if it doesn't
//   - error: nil if successful, otherwise contains the error message
func (r *RedisService) Exists(key string) (bool, error) <span class="cov8" title="1">{
        count, err := r.client.Exists(r.ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, apperror.NewCacheExistsError(err.Error())
        }</span>
        <span class="cov8" title="1">return count &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package services

import (
        "time"

        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/repositories"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

type IRefreshTokenService interface {
        Create(user *models.User, ipAddress string) (*JwtResult, error)
        Update(token string, ipAddress string) (*RefreshTokenResult, error)
}

type RefreshTokenService struct {
        repo repositories.IRefreshTokenRepository
}

// NewRefreshTokenService creates a new instance of RefreshTokenService
// Parameters:
//   - repo: Pointer to RefreshTokenRepository that handles refresh token database operations
//
// Returns:
//   - *RefreshTokenService: New instance of RefreshTokenService initialized with the provided repository
func NewRefreshTokenService(repo repositories.IRefreshTokenRepository) *RefreshTokenService <span class="cov8" title="1">{
        return &amp;RefreshTokenService{
                repo: repo,
        }
}</span>

// Create creates a new refresh token for a user
// Parameters:
//   - user: User model containing user information
//   - ipAddress: IP address of the user making the request
//
// Returns:
//   - *configs.JwtResult: Contains the generated token and expiration time
//   - error: Error if token creation fails
func (service *RefreshTokenService) Create(user *models.User, ipAddress string) (*JwtResult, error) <span class="cov8" title="1">{
        tokenString := utils.GenerateRandomString(60)
        expiredAt := time.Now().Add(time.Hour * 24 * 30).Unix()
        token := models.RefreshToken{
                RefreshToken: tokenString,
                IpAddress:    ipAddress, // ipaddress of user
                UsedCount:    0,         // init is zero
                ExpiredAt:    expiredAt, // 30 days
                UserID:       user.ID,   // userId
        }

        err := service.repo.Create(&amp;token)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewDBInsertError(err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;JwtResult{
                Token:     tokenString,
                ExpiresAt: expiredAt,
        }, nil</span>
}

type RefreshTokenResult struct {
        Token  *JwtResult
        UserId uint
}

// Update replaces an existing refresh token with a new one
// Parameters:
//   - tokenString: The existing refresh token string to be replaced
//   - ipAddress: IP address of the user making the request
//
// Returns:
//   - *RefreshTokenResult: Contains the new token information and associated user ID
//   - *appError.AppError: Error if token creation/update fails
//
// The function:
//  1. Finds the existing token record
//  2. Generates a new random token string
//  3. Updates the token record with new token, expiry and IP
//  4. Returns the new token details and associated user ID
func (service *RefreshTokenService) Update(tokenString string, ipAddress string) (*RefreshTokenResult, error) <span class="cov8" title="1">{
        result, err := service.repo.FindByToken(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewNotFoundError(err.Error())
        }</span>
        // Update new token
        <span class="cov8" title="1">newToken := utils.GenerateRandomString(60)
        expiredAt := time.Now().Add(time.Hour * 24 * 30).Unix()

        result.RefreshToken = newToken
        result.ExpiredAt = expiredAt
        result.IpAddress = ipAddress
        result.UsedCount += 1

        if err := service.repo.Update(result); err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewDBUpdateError(err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;RefreshTokenResult{
                Token: &amp;JwtResult{
                        Token:     newToken,
                        ExpiresAt: expiredAt,
                },
                UserId: result.UserID,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package services

import (
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/repositories"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

type IRoleService interface {
        GetByID(id int64) (*models.Role, error)
        Create(role *models.Role) error
        Update(role *models.Role) error
        Delete(id int64) error
}

type RoleService struct {
        repo repositories.IRoleRepository
}

func NewRoleService(repo repositories.IRoleRepository) *RoleService <span class="cov8" title="1">{
        return &amp;RoleService{
                repo: repo,
        }
}</span>

// Get retrieves a role by its ID from the repository
// Parameters:
//   - id: The unique identifier of the role to retrieve
//
// Returns:
//   - *models.Role: The role object if found
//   - *appError.AppError: Any error that occurred during the operation
func (service *RoleService) GetByID(id int64) (*models.Role, error) <span class="cov8" title="1">{
        data, err := service.repo.GetByID(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewNotFoundError(err.Error())
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// Create adds a new role to the repository
// Parameters:
//   - role: The role object to be created
//
// Returns:
//   - *appError.AppError: Any error that occurred during the operation
func (service *RoleService) Create(role *models.Role) error <span class="cov8" title="1">{
        err := service.repo.Create(role)
        if err != nil </span><span class="cov8" title="1">{
                return apperror.NewDBInsertError(err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Update modifies an existing role in the repository
// Parameters:
//   - role: The role object containing the updated information
//
// Returns:
//   - error: Any error that occurred during the operation
func (service *RoleService) Update(role *models.Role) error <span class="cov8" title="1">{
        err := service.repo.Update(role)
        if err != nil </span><span class="cov8" title="1">{
                return apperror.NewDBUpdateError(err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete removes a role from the repository by its ID
// Parameters:
//   - id: The unique identifier of the role to delete
//
// Returns:
//   - error: Any error that occurred during the operation, including if the role is not found
func (service *RoleService) Delete(id int64) error <span class="cov8" title="1">{
        role, err := service.repo.GetByID(id)
        if err != nil </span><span class="cov8" title="1">{
                return apperror.NewDBQueryError(err.Error())
        }</span>
        <span class="cov8" title="1">err = service.repo.Delete(role)
        if err != nil </span><span class="cov8" title="1">{
                return apperror.NewDBDeleteError(err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package services

import (
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/repositories"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

type ISettingService interface {
        GetSetting() ([]models.Setting, error)
        GetSettingByKey(key string) (*models.Setting, error)
        Update(setting *models.Setting) error
        Create(setting *models.Setting) error
}

type SettingService struct {
        repo repositories.ISettingRepository
}

func NewSettingService(repo repositories.ISettingRepository) *SettingService <span class="cov8" title="1">{
        return &amp;SettingService{
                repo: repo,
        }
}</span>

// GetSetting retrieves all settings from the repository
// Returns:
//   - *[]models.Setting: pointer to a slice of Setting models containing all settings
//   - error: any error encountered during the retrieval operation
func (service *SettingService) GetSetting() ([]models.Setting, error) <span class="cov8" title="1">{
        data, err := service.repo.GetAll()
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewInternalError(err.Error())
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// GetSettingByKey retrieves a specific setting from the repository by its key
// Parameters:
//   - key: string representing the unique identifier of the setting
//
// Returns:
//   - *models.Setting: pointer to the Setting model if found
//   - error: any error encountered during the retrieval operation
func (service *SettingService) GetSettingByKey(key string) (*models.Setting, error) <span class="cov8" title="1">{
        data, err := service.repo.GetByKey(key)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewNotFoundError(err.Error())
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// Update updates a single setting in the repository
// Parameters:
//   - setting: pointer to the Setting model to be updated
//
// Returns:
//   - *models.Setting: pointer to the updated Setting model
//   - error: any error encountered during the update operation
func (service *SettingService) Update(setting *models.Setting) error <span class="cov8" title="1">{
        err := service.repo.Update(setting)
        if err != nil </span><span class="cov8" title="1">{
                return apperror.NewDBUpdateError(err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Create creates a new setting in the repository
// Parameters:
//   - setting: pointer to the Setting model to be created
//
// Returns:
//   - *models.Setting: pointer to the created Setting model
//   - *appError.AppError: any error encountered during the creation operation
func (service *SettingService) Create(setting *models.Setting) error <span class="cov8" title="1">{
        err := service.repo.Create(setting)
        if err != nil </span><span class="cov8" title="1">{
                return apperror.NewDBInsertError(err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package services

import (
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/repositories"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

type IUserService interface {
        PaginateUser(page, limit int) (*utils.Pagination, error)
        GetUser(id uint) (*models.User, error)
        GetUserByEmail(email string) (*models.User, error)
        CreateUser(user *models.User, roleIds []uint) error
        UpdateUser(user *models.User) error
        DeleteUser(id uint) error
        GetUserByToken(token string) (*models.User, error)
        GetProfile(id uint) (*models.User, error)
        UpdateProfile(user *models.User) error
}

type UserService struct {
        repo repositories.IUserRepository
}

func NewUserService(repo repositories.IUserRepository) *UserService <span class="cov8" title="1">{
        return &amp;UserService{
                repo: repo,
        }
}</span>

/**
 * PaginateUser retrieves a paginated list of users from the database.
 * Parameters:
 *   - page: The page number to retrieve (default is 1)
 *   - limit: The number of users per page (default is 10)
 *
 * Returns:
 *   - *utils.Pagination: A pointer to the pagination object containing user data
 *   - error: nil if successful, otherwise returns the error that occurred
 *
 * Example:
 *   users, err := service.PaginateUser(1, 50) // Gets the second page of users
 */
func (service *UserService) PaginateUser(page, limit int) (*utils.Pagination, error) <span class="cov8" title="1">{
        data, err := service.repo.PaginateUser(page, limit)

        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewDBQueryError(err.Error())
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// GetUser retrieves a user by their ID from the database.
// Parameters:
//   - id: The unique identifier of the user to retrieve
//
// Returns:
//   - *models.User: A pointer to the user record if found
//   - error: nil if successful, otherwise returns the error that occurred
//
// Example:
//
//        user, err := service.GetUser(1) // Gets user with ID 1
func (service *UserService) GetUser(id uint) (*models.User, error) <span class="cov8" title="1">{
        data, err := service.repo.GetByID(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewNotFoundError(err.Error())
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// GetUserByEmail retrieves a user by their email address from the database.
// Parameters:
//   - email: The email address of the user to retrieve
//
// Returns:
//   - *models.User: A pointer to the user record if found
//   - *appError.AppError: nil if successful, otherwise returns the error that occurred
//
// Example:
//
//        user, err := service.GetUserByEmail("john@example.com")
func (service *UserService) GetUserByEmail(email string) (*models.User, error) <span class="cov8" title="1">{
        data, err := service.repo.FindByField("email", email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewNotFoundError(err.Error())
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// CreateUser creates a new user in the database and assigns roles to them.
// Parameters:
//   - user: Pointer to models.User containing the user information to create
//   - roleIds: Slice of role IDs to assign to the user
//
// Returns:
//   - *error: nil if successful, otherwise returns the error that occurred
func (service *UserService) CreateUser(user *models.User, roleIds []uint) error <span class="cov0" title="0">{
        tx := service.repo.GetDB().Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return apperror.NewDBInsertError(tx.Error.Error())
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        panic(r)</span>
                }
        }()

        <span class="cov0" title="0">createdUser, err := service.repo.CreateWithTx(tx, user)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return apperror.NewDBInsertError(err.Error())
        }</span>

        <span class="cov0" title="0">for _, roleId := range roleIds </span><span class="cov0" title="0">{
                userRole := models.UserRole{
                        UserID: createdUser.ID,
                        RoleID: roleId,
                }
                if err := tx.Create(&amp;userRole).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return apperror.NewDBInsertError(err.Error())
                }</span>
        }

        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return apperror.NewDBInsertError(err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateUser updates an existing user's information in the database.
// Parameters:
//   - user: Pointer to models.User containing the updated user information
//
// Returns:
//   - error: nil if successful, otherwise returns the error that occurred
//
// Example:
//
//        user := &amp;models.User{
//            ID: 1,
//            Name: "Updated Name",
//            Email: "updated@example.com",
//        }
//        err := service.UpdateUser(user)
func (service *UserService) UpdateUser(user *models.User) error <span class="cov8" title="1">{
        err := service.repo.Update(user)
        if err != nil </span><span class="cov8" title="1">{
                return apperror.NewDBUpdateError(err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// DeleteUser removes a user from the database by their ID.
// Parameters:
//   - id: The unique identifier of the user to delete
//
// Returns:
//   - *appError.AppError: nil if successful, otherwise returns the error that occurred
//
// Example:
//
//        err := service.DeleteUser(1) // Deletes user with ID 1
func (service *UserService) DeleteUser(id uint) error <span class="cov8" title="1">{
        err := service.repo.Delete(id)
        if err != nil </span><span class="cov8" title="1">{
                return apperror.NewDBDeleteError(err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetUserByToken retrieves a user by their authentication token from the database.
// Parameters:
//   - token: The authentication token string associated with the user
//
// Returns:
//   - *models.User: A pointer to the user record if found
//   - error: nil if successful, otherwise returns the error that occurred
//
// Example:
//
//        user, err := service.GetUserByToken("abc123token")
func (service *UserService) GetUserByToken(token string) (*models.User, error) <span class="cov8" title="1">{
        data, err := service.repo.FindByField("token", token)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewNotFoundError(err.Error())
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// GetProfile retrieves a user's profile information by their ID from the database.
// Parameters:
//   - id: The unique identifier of the user whose profile to retrieve
//
// Returns:
//   - *models.User: A pointer to the user profile record if found
//   - error: nil if successful, otherwise returns the error that occurred
//
// Example:
//
//        profile, err := service.GetProfile(1) // Gets profile for user with ID 1
func (service *UserService) GetProfile(id uint) (*models.User, error) <span class="cov8" title="1">{
        data, err := service.repo.GetProfile(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.NewNotFoundError(err.Error())
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// UpdateProfile updates a user's profile information in the database.
// Parameters:
//   - user: Pointer to models.User containing the updated profile information
//
// Returns:
//   - error: nil if successful, otherwise returns the error that occurred
//
// Example:
//
//        user := &amp;models.User{
//            ID: 1,
//            Name: "Updated Name",
//            Bio: "Updated bio"
//        }
//        err := service.UpdateProfile(user)
func (service *UserService) UpdateProfile(user *models.User) error <span class="cov8" title="1">{
        err := service.repo.UpdateProfile(user)
        if err != nil </span><span class="cov8" title="1">{
                return apperror.NewDBUpdateError(err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package utils

import "golang.org/x/crypto/bcrypt"

// CheckPasswordHash compares a plain text password with a hashed password
// Returns true if they match, false otherwise
func CheckPasswordHash(password, hashPassword string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hashPassword), []byte(password))
        return err == nil
}</span>

func HashPasswordWithCost(password string, cost int) string <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), cost)
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return string(hashedPassword)</span>
}

// Default wrapper to use in production
func HashPassword(password string) string <span class="cov8" title="1">{
        return HashPasswordWithCost(password, bcrypt.DefaultCost)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package utils

import (
        "os"
        "strconv"
)

// GetEnv retrieves a string value from the environment with a fallback default value
// Parameters:
//   - key: The environment variable key to look up
//   - defaultValue: The default string value to return if the environment variable is not set
//
// Returns:
//   - string: The value from the environment or the default value
func GetEnv(key string, defaultValue string) string <span class="cov8" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// GetEnvAsInt retrieves an integer value from the environment with a fallback default value
// Parameters:
//   - key: The environment variable key to look up
//   - defaultValue: The default integer value to return if the environment variable is not set or cannot be parsed
//
// Returns:
//   - int: The parsed integer value from the environment or the default value
func GetEnvAsInt(key string, defaultValue int) int <span class="cov8" title="1">{
        valueStr := GetEnv(key, "")
        if value, err := strconv.Atoi(valueStr); err == nil </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package utils

import (
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/internal/constants"
)

func CalculateTotalPages(totalRows int64, limit int) int <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">totalPages := int(totalRows) / limit
        if int(totalRows)%limit != 0 </span><span class="cov8" title="1">{
                totalPages++
        }</span>
        <span class="cov8" title="1">return totalPages</span>
}

func ParsePageAndLimit(c *gin.Context) (int, int) <span class="cov8" title="1">{
        var pageInt, limitInt int64
        var page, limit string

        page = c.Query("page")
        limit = c.Query("limit")

        pageInt, err := strconv.ParseInt(page, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                pageInt = 1
        }</span>
        <span class="cov8" title="1">if pageInt &lt;= 0 </span><span class="cov8" title="1">{
                pageInt = 1
        }</span>

        <span class="cov8" title="1">limitInt, err2 := strconv.ParseInt(limit, 10, 64)
        if err2 != nil </span><span class="cov8" title="1">{
                limitInt = int64(constants.LIMIT)
        }</span>
        <span class="cov8" title="1">if limitInt &lt;= 0 </span><span class="cov8" title="1">{
                limitInt = int64(constants.LIMIT)
        }</span>

        <span class="cov8" title="1">return int(pageInt), int(limitInt)</span>
}

type Pagination struct {
        Page       int `json:"page"`
        Limit      int `json:"limit"`
        TotalItems int `json:"totalItems"`
        TotalPages int `json:"totalPages"`
        Data       any `json:"data"`
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package utils

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

// RespondWithError sends a JSON error response with the given status code and error
// Parameters:
//   - ctx: Gin context for the request
//   - statusCode: HTTP status code to return
//   - err: Error to be serialized as JSON response body
//   - 1. If the error is a ValidationError, it includes validation error code, message, and fields.
//   - 2. If the error is an AppError, it includes application error code and message.
//   - 3. If the error is neither, it returns a generic internal error response.
func RespondWithError(ctx *gin.Context, err error) <span class="cov8" title="1">{
        // 1. If the error is a ValidationError, return its code, message, and fields
        if validateErr, ok := err.(*apperror.ValidationError); ok </span><span class="cov0" title="0">{
                ctx.AbortWithStatusJSON(
                        http.StatusBadRequest,
                        gin.H{
                                "code":    validateErr.Code,
                                "message": validateErr.Message,
                                "fields":  validateErr.Fields,
                        },
                )
                return
        }</span>

        // 2. If the error is an AppError, return its code and message
        <span class="cov8" title="1">if appErr, ok := err.(*apperror.AppError); ok </span><span class="cov8" title="1">{
                ctx.AbortWithStatusJSON(
                        appErr.HttpStatusCode,
                        gin.H{
                                "code":    appErr.Code,
                                "message": appErr.Message,
                        },
                )
                return
        }</span>
        // 3. If the error is not a ValidationError or AppError, return a generic internal error
        <span class="cov8" title="1">ctx.AbortWithStatusJSON(
                http.StatusInternalServerError,
                gin.H{
                        "code":    apperror.ErrInternal,
                        "message": err.Error(),
                },
        )</span>
}

// RespondWithOK sends a JSON response with the given status code and body
// Parameters:
//   - ctx: Gin context for the request
//   - statusCode: HTTP status code to return
//   - body: Data to be serialized as JSON response body
func RespondWithOK(ctx *gin.Context, statusCode int, body any) <span class="cov8" title="1">{
        ctx.AbortWithStatusJSON(statusCode, body)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package utils

import (
        "fmt"
        "reflect"
        "strings"
)

// CensorSensitiveData censors sensitive data in complex data structures
func CensorSensitiveData(data any, maskFields []string) any <span class="cov8" title="1">{
        // Handle nil input
        if data == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Use reflection to handle more dynamic type checking
        <span class="cov8" title="1">val := reflect.ValueOf(data)

        switch val.Kind() </span>{
        case reflect.Slice:<span class="cov8" title="1">
                return censorSlice(data, maskFields)</span>
        case reflect.Map:<span class="cov8" title="1">
                return censorMap(data, maskFields)</span>
        case reflect.Struct:<span class="cov8" title="1">
                return censorStruct(data, maskFields)</span>
        case reflect.Ptr:<span class="cov8" title="1">
                // Dereference pointer and recursively censor
                if val.IsNil() </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return CensorSensitiveData(val.Elem().Interface(), maskFields)</span>
        case reflect.String:<span class="cov8" title="1">
                return data</span>
        default:<span class="cov8" title="1">
                return data</span>
        }
}

// censorSlice handles censoring slice types
func censorSlice(data any, maskFields []string) any <span class="cov8" title="1">{
        val := reflect.ValueOf(data)
        censoredSlice := reflect.MakeSlice(val.Type(), val.Len(), val.Len())

        for i := range val.Len() </span><span class="cov8" title="1">{
                item := val.Index(i).Interface()
                censoredItem := CensorSensitiveData(item, maskFields)
                censoredSlice.Index(i).Set(reflect.ValueOf(censoredItem))
        }</span>

        <span class="cov8" title="1">return censoredSlice.Interface()</span>
}

// censorMap handles censoring map types
func censorMap(data any, maskFields []string) any <span class="cov8" title="1">{
        val := reflect.ValueOf(data)
        censoredMap := reflect.MakeMap(val.Type())

        iter := val.MapRange()
        for iter.Next() </span><span class="cov8" title="1">{
                key := iter.Key()
                value := iter.Value()

                // Check if the key (converted to string) is in maskFields
                keyStr := fmt.Sprintf("%v", key.Interface())

                var censoredValue reflect.Value
                if contains(maskFields, keyStr) </span><span class="cov8" title="1">{
                        // Mask the entire value if the key matches
                        censoredValue = reflect.ValueOf(maskValue(value.Interface()))
                }</span> else<span class="cov8" title="1"> {
                        // Recursively censor nested structures
                        censoredValue = reflect.ValueOf(CensorSensitiveData(value.Interface(), maskFields))
                }</span>

                <span class="cov8" title="1">censoredMap.SetMapIndex(key, censoredValue)</span>
        }

        <span class="cov8" title="1">return censoredMap.Interface()</span>
}

// censorStruct handles censoring struct types
func censorStruct(data any, maskFields []string) any <span class="cov8" title="1">{
        val := reflect.ValueOf(data)
        typ := val.Type()

        censoredStruct := reflect.New(typ).Elem()

        for i := 0; i &lt; val.NumField(); i++ </span><span class="cov8" title="1">{
                field := val.Field(i)
                fieldType := typ.Field(i)

                if contains(maskFields, fieldType.Name) </span><span class="cov8" title="1">{
                        // Trường cần mask
                        if field.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                if field.IsNil() </span><span class="cov8" title="1">{
                                        // Nếu con trỏ nil thì giữ nguyên nil
                                        censoredStruct.Field(i).Set(reflect.Zero(field.Type()))
                                }</span> else<span class="cov8" title="1"> {
                                        // Mask giá trị bên trong con trỏ
                                        maskedVal := maskValue(field.Elem().Interface())
                                        maskedValReflect := reflect.ValueOf(maskedVal)

                                        // Tạo con trỏ mới cùng kiểu với trường
                                        ptr := reflect.New(fieldType.Type.Elem())
                                        ptr.Elem().Set(maskedValReflect)

                                        censoredStruct.Field(i).Set(ptr)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // Trường không phải con trỏ thì mask trực tiếp
                                censoredStruct.Field(i).Set(reflect.ValueOf(maskValue(field.Interface())))
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Trường không cần mask, đệ quy censor nested
                        censoredValue := CensorSensitiveData(field.Interface(), maskFields)
                        if field.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                if field.IsNil() </span><span class="cov8" title="1">{
                                        censoredStruct.Field(i).Set(reflect.Zero(field.Type()))
                                }</span> else<span class="cov8" title="1"> {
                                        ptr := reflect.New(fieldType.Type.Elem())
                                        ptr.Elem().Set(reflect.ValueOf(censoredValue))
                                        censoredStruct.Field(i).Set(ptr)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                censoredStruct.Field(i).Set(reflect.ValueOf(censoredValue))
                        }</span>
                }
        }

        <span class="cov8" title="1">return censoredStruct.Interface()</span>
}

// contains checks if a slice contains a given string
func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, v := range slice </span><span class="cov8" title="1">{
                if strings.EqualFold(v, item) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// maskValue provides advanced masking for different value types
func maskValue(value any) any <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return maskString(v)</span>
        case fmt.Stringer:<span class="cov0" title="0">
                return maskString(v.String())</span>
        case []byte:<span class="cov8" title="1">
                masked := maskString(string(v))
                return []byte(masked)</span>
        case nil:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return maskReflectedValue(value)</span>
        }
}

// maskString provides sophisticated string masking
func maskString(s string) string <span class="cov8" title="1">{
        // Default masking for other strings
        if len(s) &gt; 2 </span><span class="cov8" title="1">{
                maskLen := min(len(s)-2, 8)
                return string(s[0]) + strings.Repeat("*", maskLen) + string(s[len(s)-1])
        }</span>
        <span class="cov8" title="1">return strings.Repeat("*", len(s))</span>
}

// maskReflectedValue handles masking for complex types using reflection
func maskReflectedValue(value any) any <span class="cov0" title="0">{
        val := reflect.ValueOf(value)

        switch val.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                // Create a masked slice of the same length
                maskedSlice := reflect.MakeSlice(val.Type(), val.Len(), val.Len())
                for i := range val.Len() </span><span class="cov0" title="0">{
                        maskedSlice.Index(i).Set(reflect.ValueOf("*****"))
                }</span>
                <span class="cov0" title="0">return maskedSlice.Interface()</span>
        case reflect.Struct:<span class="cov0" title="0">
                // Create a struct with all fields masked
                maskedStruct := reflect.New(val.Type()).Elem()
                for i := range val.NumField() </span><span class="cov0" title="0">{
                        maskedStruct.Field(i).Set(reflect.ValueOf("*****"))
                }</span>
                <span class="cov0" title="0">return maskedStruct.Interface()</span>
        default:<span class="cov0" title="0">
                return "*****"</span>
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package utils

import (
        "math/rand"
        "time"
)

// GenerateRandomString generates a random string of specified length using alphanumeric characters
// Parameters:
//   - n: length of the random string to generate
//
// Returns:
//   - string: randomly generated alphanumeric string of length n
func GenerateRandomString(n int) string <span class="cov8" title="1">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        seededRand := rand.New(rand.NewSource(time.Now().UnixNano()))

        result := make([]byte, n)
        for i := range result </span><span class="cov8" title="1">{
                result[i] = charset[seededRand.Intn(len(charset))]
        }</span>
        <span class="cov8" title="1">return string(result)</span>
}

// StringToPtr converts a string to a pointer to a string
// Parameters:
//   - s: the string to convert
//
// Returns:
//   - *string: pointer to the string, or nil if the input string is empty
func StringToPtr(s string) *string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;s</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package utils

import (
        "errors"
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/gin-gonic/gin/binding"
        "github.com/go-playground/validator/v10"
        "github.com/vfa-khuongdv/golang-cms/pkg/apperror"
)

// InitValidator initializes the validator engine and registers custom validation rules.
// This function is called during the application startup to ensure that
func InitValidator() <span class="cov8" title="1">{
        if v, ok := binding.Validator.Engine().(*validator.Validate); ok </span><span class="cov8" title="1">{
                v.RegisterValidation("valid_birthday", ValidateBirthday)
                v.RegisterValidation("not_blank", ValidateNotBlank)
        }</span>
}

// Custom validation func to check no spaces at all in the string
func ValidateNotBlank(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        str := fl.Field().String()
        trimmed := strings.TrimSpace(str)
        return trimmed != ""
}</span>

// ValidateBirthday checks if the birthday is in a valid format and not a future date.
func ValidateBirthday(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        birthdayStr := fl.Field().String()
        layout := "2006-01-02" // Format: YYYY-MM-DD

        // Parse the birthday to check the format
        parsedDate, err := time.Parse(layout, birthdayStr)
        if err != nil </span><span class="cov8" title="1">{
                return false // Invalid date format
        }</span>

        // Check if the birthday is in the future
        <span class="cov8" title="1">if parsedDate.After(time.Now()) </span><span class="cov8" title="1">{
                return false // Invalid: birthday can't be in the future
        }</span>

        <span class="cov8" title="1">return true</span> // Valid birthday
}

// TranslateValidationErrors converts validation errors from the validator package
// into a structured ValidationError that can be returned in API responses.
func TranslateValidationErrors(err error, obj any) *apperror.ValidationError <span class="cov8" title="1">{
        var ve validator.ValidationErrors
        if !errors.As(err, &amp;ve) </span><span class="cov0" title="0">{
                return &amp;apperror.ValidationError{
                        Code:    apperror.ErrValidationFailed,
                        Message: err.Error(),
                        Fields:  []apperror.FieldError{},
                }
        }</span>

        <span class="cov8" title="1">var fieldErrors []apperror.FieldError

        // Reflect type for JSON tag lookup
        objType := reflect.TypeOf(obj)
        if objType.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                objType = objType.Elem()
        }</span>

        <span class="cov8" title="1">for _, fe := range ve </span><span class="cov8" title="1">{
                ns := fe.StructNamespace() // e.g. "Settings[0].Value"
                parts := strings.Split(ns, ".")

                jsonParts := []string{}
                currType := objType

                for i, part := range parts </span><span class="cov8" title="1">{
                        fieldName := part
                        indexSuffix := ""

                        // Handle slice index, e.g. Settings[0]
                        if idx := strings.Index(part, "["); idx != -1 </span><span class="cov0" title="0">{
                                fieldName = part[:idx]
                                indexSuffix = part[idx:]
                        }</span>

                        <span class="cov8" title="1">field, found := currType.FieldByName(fieldName)
                        if !found </span><span class="cov0" title="0">{
                                // Join the rest with dots and append
                                jsonParts = append(jsonParts, strings.Join(parts[i:], "."))
                                break</span>
                        }

                        <span class="cov8" title="1">jsonTag := field.Tag.Get("json")
                        jsonName := strings.Split(jsonTag, ",")[0]
                        if jsonName == "" || jsonName == "-" </span><span class="cov8" title="1">{
                                jsonName = fieldName
                        }</span>

                        <span class="cov8" title="1">jsonParts = append(jsonParts, jsonName+indexSuffix)

                        currType = field.Type
                        // Dereference pointers
                        for currType.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                currType = currType.Elem()
                        }</span>
                        // If slice or array, go to element type
                        <span class="cov8" title="1">if currType.Kind() == reflect.Slice || currType.Kind() == reflect.Array </span><span class="cov8" title="1">{
                                currType = currType.Elem()
                        }</span>
                }

                <span class="cov8" title="1">fieldName := strings.Join(jsonParts, ".")

                param := fe.Param()
                var msg string

                switch fe.Tag() </span>{
                case "required":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s is required", fieldName)</span>
                case "email":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a valid email address", fieldName)</span>
                case "url":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a valid URL", fieldName)</span>
                case "uuid":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a valid UUID", fieldName)</span>
                case "len":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be exactly %s characters long", fieldName, param)</span>
                case "min":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be at least %s characters long or numeric", fieldName, param)</span>
                case "max":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be at most %s characters long or numeric", fieldName, param)</span>
                case "eq":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be equal to %s", fieldName, param)</span>
                case "ne":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must not be equal to %s", fieldName, param)</span>
                case "lt":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be less than %s", fieldName, param)</span>
                case "lte":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be less than or equal to %s", fieldName, param)</span>
                case "gt":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be greater than %s", fieldName, param)</span>
                case "gte":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be greater than or equal to %s", fieldName, param)</span>
                case "oneof":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be one of [%s]", fieldName, param)</span>
                case "contains":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must contain '%s'", fieldName, param)</span>
                case "excludes":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must not contain '%s'", fieldName, param)</span>
                case "startswith":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must start with '%s'", fieldName, param)</span>
                case "endswith":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must end with '%s'", fieldName, param)</span>
                case "ip":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a valid IP address", fieldName)</span>
                case "ipv4":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a valid IPv4 address", fieldName)</span>
                case "ipv6":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a valid IPv6 address", fieldName)</span>
                case "datetime":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a valid datetime (format: %s)", fieldName, param)</span>
                case "numeric":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a numeric value", fieldName)</span>
                case "boolean":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a boolean value", fieldName)</span>
                case "alpha":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must contain only letters", fieldName)</span>
                case "alphanum":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must contain only letters and numbers", fieldName)</span>
                case "alphanumunicode":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must contain only unicode letters and numbers", fieldName)</span>
                case "ascii":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must contain only ASCII characters", fieldName)</span>
                case "printascii":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must contain only printable ASCII characters", fieldName)</span>
                case "base64":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a valid base64 string", fieldName)</span>
                case "containsany":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must contain at least one of the characters in '%s'", fieldName, param)</span>
                case "excludesall":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must not contain any of the characters in '%s'", fieldName, param)</span>
                case "excludesrune":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must not contain the rune '%s'", fieldName, param)</span>
                case "isdefault":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be the default value", fieldName)</span>
                case "unique":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must contain unique values", fieldName)</span>
                case "valid_birthday":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must be a valid date (YYYY-MM-DD) and not in the future", fieldName)</span>
                case "not_blank":<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s must not be blank", fieldName)</span>
                default:<span class="cov8" title="1">
                        msg = fmt.Sprintf("%s is invalid", fieldName)</span>
                }

                <span class="cov8" title="1">fieldErrors = append(fieldErrors, apperror.FieldError{
                        Field:   fieldName,
                        Message: msg,
                })</span>
        }

        <span class="cov8" title="1">return apperror.NewValidationError("Validation failed", fieldErrors)</span>
}

// The utility function to map JSON errors to FieldError structs.
func MapJsonToFieldErrors(json any) []apperror.FieldError <span class="cov0" title="0">{
        var fieldErrors []apperror.FieldError

        if items, ok := json.([]any); ok </span><span class="cov0" title="0">{
                for _, item := range items </span><span class="cov0" title="0">{
                        if fieldMap, ok := item.(map[string]any); ok </span><span class="cov0" title="0">{
                                field, _ := fieldMap["field"].(string)
                                message, _ := fieldMap["message"].(string)

                                fieldErrors = append(fieldErrors, apperror.FieldError{
                                        Field:   field,
                                        Message: message,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">return fieldErrors</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package apperror

import "fmt"

// AppError represents a custom error with a code and message.
type AppError struct {
        HttpStatusCode int    `json:"-"`       // HTTP status code (optional)
        Code           int    `json:"code"`    // Error code
        Message        string `json:"message"` // Error message
}

// Error implements the error interface.
func (e *AppError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("code: %d, message: %s", e.Code, e.Message)
}</span>

// Wrap creates a new AppError with an underlying error.
func Wrap(httpStatusCode, code int, message string, err error) *AppError <span class="cov8" title="1">{
        return &amp;AppError{
                HttpStatusCode: httpStatusCode,
                Code:           code,
                Message:        message,
        }
}</span>

// New creates a new AppError without an underlying error.
func New(httpStatusCode, code int, message string) *AppError <span class="cov8" title="1">{
        return &amp;AppError{
                HttpStatusCode: httpStatusCode,
                Code:           code,
                Message:        message,
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package apperror

import "net/http"

// === Generic errors ===
func NewInternalError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrInternal,
                Message:        message,
        }
}</span>
func NewNotFoundError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusNotFound,
                Code:           ErrNotFound,
                Message:        message,
        }
}</span>
func NewBadRequestError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusBadRequest,
                Code:           ErrBadRequest,
                Message:        message,
        }
}</span>
func NewUnauthorizedError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusUnauthorized,
                Code:           ErrUnauthorized,
                Message:        message,
        }
}</span>
func NewForbiddenError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusForbidden,
                Code:           ErrForbidden,
                Message:        message,
        }
}</span>

// === Database errors ===
func NewDBConnectionError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrDBConnection,
                Message:        message,
        }
}</span>

func NewDBQueryError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrDBQuery,
                Message:        message,
        }
}</span>

func NewDBInsertError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrDBInsert,
                Message:        message,
        }
}</span>

func NewDBUpdateError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrDBUpdate,
                Message:        message,
        }
}</span>

func NewDBDeleteError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrDBDelete,
                Message:        message,
        }
}</span>

// === Cache errors ===
func NewCacheSetError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrCacheSet,
                Message:        message,
        }
}</span>
func NewCacheGetError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrCacheGet,
                Message:        message,
        }
}</span>
func NewCacheDeleteError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrCacheDelete,
                Message:        message,
        }
}</span>
func NewCacheListError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrCacheList,
                Message:        message,
        }
}</span>
func NewCacheExistsError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrCacheExists,
                Message:        message,
        }
}</span>

// === Authentication errors ===
func NewTokenExpiredError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusBadRequest,
                Code:           ErrTokenExpired,
                Message:        message,
        }
}</span>
func NewInvalidPasswordError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusBadRequest,
                Code:           ErrInvalidPassword,
                Message:        message,
        }
}</span>
func NewPasswordHashFailedError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusInternalServerError,
                Code:           ErrPasswordHashFailed,
                Message:        message,
        }
}</span>
func NewPasswordMismatchError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusBadRequest,
                Code:           ErrPasswordMismatch,
                Message:        message,
        }
}</span>
func NewPasswordUnchangedError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusBadRequest,
                Code:           ErrPasswordUnchanged,
                Message:        message,
        }
}</span>

// === Common errors ===
func NewParseError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusBadRequest,
                Code:           ErrParseError,
                Message:        message,
        }
}</span>
func NewValidationDataError(message string) *AppError <span class="cov0" title="0">{
        return &amp;AppError{
                HttpStatusCode: http.StatusBadRequest,
                Code:           ErrValidationFailed,
                Message:        message,
        }
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package apperror

import (
        "fmt"
)

type FieldError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

type ValidationError struct {
        Code    int          `json:"code"`    // Error code
        Message string       `json:"message"` // Error message
        Fields  []FieldError `json:"fields"`  // List of validation errors
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("code: %d, message: %s, fields: %v", e.Code, e.Message, e.Fields)
}</span>

func (e *ValidationError) Wrap(httpStatusCode int, code int, message string) *ValidationError <span class="cov0" title="0">{
        return &amp;ValidationError{
                Code:    code,
                Message: message,
                Fields:  e.Fields,
        }
}</span>

func NewValidationError(message string, fieldErrors []FieldError) *ValidationError <span class="cov0" title="0">{
        return &amp;ValidationError{
                Code:    ErrValidationFailed,
                Message: message,
                Fields:  fieldErrors,
        }
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package logger

import (
        "os"

        log "github.com/sirupsen/logrus"
)

func Init() <span class="cov8" title="1">{
        // Log as JSON instead of the default ASCII formatter.
        log.SetFormatter(&amp;log.JSONFormatter{})
        // Output to stdout instead of the default stderr
        log.SetOutput(os.Stdout)

}</span>

// Info logs information level messages
// Takes variadic arguments and logs them at INFO level
func Info(args ...interface{}) <span class="cov8" title="1">{
        log.Info(args...)
}</span>

// Infof logs formatted information level messages
// Takes a format string and variadic arguments to format the log message
func Infof(format string, args ...interface{}) <span class="cov8" title="1">{
        log.Infof(format, args...)
}</span>

// Debug logs debug level messages
// Takes variadic arguments and logs them at DEBUG level
func Debug(args ...interface{}) <span class="cov8" title="1">{
        log.Debug(args...)
}</span>

// Debugf logs formatted debug level messages
// Takes a format string and variadic arguments to format the log message
func Debugf(format string, args ...interface{}) <span class="cov8" title="1">{
        log.Debugf(format, args...)
}</span>

// Error logs error level messages
// Takes variadic arguments and logs them at ERROR level
func Error(args ...interface{}) <span class="cov8" title="1">{
        log.Error(args...)
}</span>

// Errorf logs formatted error level messages
// Takes a format string and variadic arguments to format the log message
func Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        log.Errorf(format, args...)
}</span>

// Fatal logs fatal level messages and then exits with status code 1
// Takes variadic arguments, logs them at FATAL level and terminates program
func Fatal(args ...interface{}) <span class="cov0" title="0">{
        log.Fatal(args...)
}</span>

// Fatalf logs formatted fatal level messages and then exits
// Takes a format string and variadic arguments, formats and logs at FATAL level before terminating
func Fatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        log.Fatalf(format, args...)
}</span>

// Warn logs warning level messages
// Takes variadic arguments and logs them at WARN level
func Warn(args ...interface{}) <span class="cov8" title="1">{
        log.Warn(args...)
}</span>

// Warnf logs formatted warning level messages
// Takes a format string and variadic arguments to format the log message
func Warnf(format string, args ...interface{}) <span class="cov8" title="1">{
        log.Warnf(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package mailer

import (
        "errors"

        "gopkg.in/gomail.v2"
)

type EmailSender interface {
        Send(to []string, subject, plainText, html string) error
}

type GomailSenderConfig struct {
        From     string
        Host     string
        Port     int
        Username string
        Password string
}

// Interface for mocking DialAndSend
type DialAndSender interface {
        DialAndSend(m ...*gomail.Message) error
}

type GomailSender struct {
        Config GomailSenderConfig
        Dialer DialAndSender
}

func NewGomailSender(config GomailSenderConfig) *GomailSender <span class="cov8" title="1">{
        dialer := gomail.NewDialer(config.Host, config.Port, config.Username, config.Password)
        return &amp;GomailSender{
                Config: config,
                Dialer: dialer,
        }
}</span>

func (s *GomailSender) Send(to []string, subject, plainText, html string) error <span class="cov8" title="1">{
        if len(to) == 0 </span><span class="cov8" title="1">{
                return errors.New("recipient list cannot be empty")
        }</span>
        <span class="cov8" title="1">if subject == "" </span><span class="cov8" title="1">{
                return errors.New("email subject cannot be empty")
        }</span>
        <span class="cov8" title="1">if plainText == "" &amp;&amp; html == "" </span><span class="cov8" title="1">{
                return errors.New("either plain text or HTML content must be provided")
        }</span>

        <span class="cov8" title="1">m := gomail.NewMessage()
        m.SetHeader("From", s.Config.From)
        m.SetHeader("To", to...)
        m.SetHeader("Subject", subject)
        if plainText != "" </span><span class="cov8" title="1">{
                m.SetBody("text/plain", plainText)
        }</span>
        <span class="cov8" title="1">if html != "" </span><span class="cov8" title="1">{
                m.AddAlternative("text/html", html)
        }</span>

        <span class="cov8" title="1">if err := s.Dialer.DialAndSend(m); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package migrator

import (
        "database/sql"
        "fmt"
        "net/url"

        _ "github.com/go-sql-driver/mysql" // MySQL database/sql driver
        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/mysql"
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

type Migrator struct {
        m *migrate.Migrate
}

// NewMigrator creates a new database migrator instance.
// It takes a migrations path and a MySQL DSN string as input.
func NewMigrator(migrationsPath, dsn string) (*Migrator, error) <span class="cov0" title="0">{
        if dsn == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("MySQL DSN must not be empty")
        }</span>

        <span class="cov0" title="0">db, err := sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">driver, err := mysql.WithInstance(db, &amp;mysql.Config{
                MigrationsTable: "schema_migrations",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create MySQL driver: %w", err)
        }</span>

        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                fmt.Sprintf("file://%s", migrationsPath),
                "mysql",
                driver,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize migrator: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Migrator{m: m}, nil</span>
}

// Close closes the migrator instance and releases associated resources.
func (m *Migrator) Close() <span class="cov0" title="0">{
        if m.m != nil </span><span class="cov0" title="0">{
                m.m.Close()
        }</span>
}

// NewMySQLDSN creates a MySQL DSN string from individual connection parameters.
func NewMySQLDSN(user, password, host, port, dbName string) string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "%s:%s@tcp(%s:%s)/%s?parseTime=true&amp;charset=utf8mb4&amp;multiStatements=true",
                url.PathEscape(user),
                url.PathEscape(password),
                host,
                port,
                dbName,
        )
}</span>

// Up applies all available up migrations.
func (m *Migrator) Up() error <span class="cov0" title="0">{
        if err := m.m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return fmt.Errorf("up migration failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Down rolls back all migrations.
func (m *Migrator) Down() error <span class="cov0" title="0">{
        if err := m.m.Down(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return fmt.Errorf("down migration failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Steps migrates up or down by a given number of steps.
func (m *Migrator) Steps(steps int) error <span class="cov0" title="0">{
        if err := m.m.Steps(steps); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return fmt.Errorf("step migration failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Version returns the current migration version and dirty state.
func (m *Migrator) Version() (uint, bool, error) <span class="cov0" title="0">{
        return m.m.Version()
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package mocks

import (
        "github.com/gin-gonic/gin"
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
)

type MockAuthService struct {
        mock.Mock
}

func (m *MockAuthService) Login(email, password string, ctx *gin.Context) (*services.LoginResponse, error) <span class="cov0" title="0">{
        args := m.Called(email, password, ctx)
        if res, ok := args.Get(0).(*services.LoginResponse); ok </span><span class="cov0" title="0">{
                return res, args.Error(1)
        }</span>
        <span class="cov0" title="0">return nil, args.Error(1)</span>
}

func (m *MockAuthService) RefreshToken(token string, ctx *gin.Context) (*services.LoginResponse, error) <span class="cov0" title="0">{
        args := m.Called(token, ctx)
        if res, ok := args.Get(0).(*services.LoginResponse); ok </span><span class="cov0" title="0">{
                return res, args.Error(1)
        }</span>
        <span class="cov0" title="0">return nil, args.Error(1)</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
)

type MockBcryptService struct {
        mock.Mock
}

func (m *MockBcryptService) HashPassword(password string) (string, error) <span class="cov0" title="0">{
        args := m.Called(password)
        return args.String(0), args.Error(1)
}</span>

func (m *MockBcryptService) CheckPasswordHash(password, hashPassword string) bool <span class="cov0" title="0">{
        args := m.Called(password, hashPassword)
        return args.Bool(0)
}</span>

func (m *MockBcryptService) HashPasswordWithCost(password string, cost int) (string, error) <span class="cov0" title="0">{
        args := m.Called(password, cost)
        return args.String(0), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "gorm.io/gorm"
)

type MockDB struct {
        mock.Mock
        *gorm.DB
}

func (m *MockDB) Begin() *gorm.DB <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).(*gorm.DB)
}</span>

func (m *MockDB) Commit() *gorm.DB <span class="cov0" title="0">{
        m.Called()
        return &amp;gorm.DB{}
}</span>

func (m *MockDB) Rollback() *gorm.DB <span class="cov0" title="0">{
        m.Called()
        return &amp;gorm.DB{}
}</span>

type MockTx struct {
        mock.Mock
        Error error
}

func (m *MockTx) Create(value interface{}) *gorm.DB <span class="cov0" title="0">{
        args := m.Called(value)
        return &amp;gorm.DB{Error: args.Error(0)}
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
)

// MockJWTService is a mock implementation of services.IJWTService
type MockJWTService struct {
        mock.Mock
}

func (m *MockJWTService) GenerateToken(id uint) (*services.JwtResult, error) <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Get(0).(*services.JwtResult), args.Error(1)
}</span>

func (m *MockJWTService) ValidateToken(tokenString string) (*services.CustomClaims, error) <span class="cov0" title="0">{
        args := m.Called(tokenString)
        return args.Get(0).(*services.CustomClaims), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
)

type MockPermissionRepository struct {
        mock.Mock
}

func (m *MockPermissionRepository) Create(item *models.Permission) error <span class="cov0" title="0">{
        args := m.Called(item)
        return args.Error(0)
}</span>

func (m *MockPermissionRepository) GetAll() ([]models.Permission, error) <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).([]models.Permission), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
)

type MockPermissionService struct {
        mock.Mock
}

func (m *MockPermissionService) GetAll() ([]models.Permission, error) <span class="cov0" title="0">{
        args := m.Called()
        if perms, ok := args.Get(0).([]models.Permission); ok </span><span class="cov0" title="0">{
                return perms, args.Error(1)
        }</span>
        <span class="cov0" title="0">return nil, args.Error(1)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package mocks

import (
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/stretchr/testify/mock"
        "golang.org/x/net/context"
)

// --- Mock Redis Client ---
type MockRedisClient struct {
        mock.Mock
}

func (m *MockRedisClient) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) *redis.StatusCmd <span class="cov0" title="0">{
        args := m.Called(ctx, key, value, ttl)
        cmd := redis.NewStatusCmd(ctx)
        cmd.SetErr(args.Error(0))
        return cmd
}</span>

func (m *MockRedisClient) Get(ctx context.Context, key string) *redis.StringCmd <span class="cov0" title="0">{
        args := m.Called(ctx, key)
        cmd := redis.NewStringCmd(ctx)
        if args.Error(0) != nil </span><span class="cov0" title="0">{
                cmd.SetErr(args.Error(0))
        }</span> else<span class="cov0" title="0"> {
                cmd.SetVal(args.String(1))
        }</span>
        <span class="cov0" title="0">return cmd</span>
}

func (m *MockRedisClient) Del(ctx context.Context, keys ...string) *redis.IntCmd <span class="cov0" title="0">{
        args := m.Called(ctx, keys)
        cmd := redis.NewIntCmd(ctx)
        cmd.SetErr(args.Error(0))
        return cmd
}</span>

func (m *MockRedisClient) Exists(ctx context.Context, keys ...string) *redis.IntCmd <span class="cov0" title="0">{
        args := m.Called(ctx, keys)
        cmd := redis.NewIntCmd(ctx)
        if args.Error(0) != nil </span><span class="cov0" title="0">{
                cmd.SetErr(args.Error(0))
        }</span> else<span class="cov0" title="0"> {
                cmd.SetVal(int64(args.Int(1)))
        }</span>
        <span class="cov0" title="0">return cmd</span>
}

func (m *MockRedisClient) LRange(ctx context.Context, key string, start, stop int64) *redis.StringSliceCmd <span class="cov0" title="0">{
        args := m.Called(ctx, key, start, stop)
        cmd := redis.NewStringSliceCmd(ctx)
        if args.Error(0) != nil </span><span class="cov0" title="0">{
                cmd.SetErr(args.Error(0))
        }</span> else<span class="cov0" title="0"> {
                cmd.SetVal(args.Get(1).([]string))
        }</span>
        <span class="cov0" title="0">return cmd</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package mocks

import (
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/stretchr/testify/mock"
)

type MockRedisService struct {
        mock.Mock
}

func (m *MockRedisService) Set(key string, value any, ttl time.Duration) error <span class="cov0" title="0">{
        args := m.Called(key, value, ttl)
        return args.Error(0)
}</span>

func (m *MockRedisService) Get(key string) (string, error) <span class="cov0" title="0">{
        args := m.Called(key)
        return args.String(0), args.Error(1)
}</span>

func (m *MockRedisService) Delete(key string) error <span class="cov0" title="0">{
        args := m.Called(key)
        return args.Error(0)
}</span>

func (m *MockRedisService) Exists(key string) (bool, error) <span class="cov0" title="0">{
        args := m.Called(key)
        return args.Bool(0), args.Error(1)
}</span>

func (m *MockRedisService) GetClient() redis.Cmdable <span class="cov0" title="0">{
        args := m.Called()
        val := args.Get(0)
        if val == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return val.(redis.Cmdable)</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
)

type MockRefreshTokenRepository struct {
        mock.Mock
}

func (m *MockRefreshTokenRepository) Create(token *models.RefreshToken) error <span class="cov0" title="0">{
        args := m.Called(token)
        return args.Error(0)
}</span>

func (m *MockRefreshTokenRepository) Update(token *models.RefreshToken) error <span class="cov0" title="0">{
        args := m.Called(token)
        return args.Error(0)
}</span>

func (m *MockRefreshTokenRepository) FindByToken(token string) (*models.RefreshToken, error) <span class="cov0" title="0">{
        args := m.Called(token)
        return args.Get(0).(*models.RefreshToken), args.Error(1)
}</span>

func (m *MockRefreshTokenRepository) First(token string) (*models.RefreshToken, error) <span class="cov0" title="0">{
        args := m.Called(token)
        return args.Get(0).(*models.RefreshToken), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
)

type MockRefreshTokenService struct {
        mock.Mock
}

func (m *MockRefreshTokenService) Create(user *models.User, ipAddress string) (*services.JwtResult, error) <span class="cov0" title="0">{
        args := m.Called(user, ipAddress)
        result, _ := args.Get(0).(*services.JwtResult)
        return result, args.Error(1)
}</span>

func (m *MockRefreshTokenService) Update(token string, ipAddress string) (*services.RefreshTokenResult, error) <span class="cov0" title="0">{
        args := m.Called(token, ipAddress)
        result, _ := args.Get(0).(*services.RefreshTokenResult)
        return result, args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
)

type MockRoleRepository struct {
        mock.Mock
}

func (m *MockRoleRepository) GetByID(id int64) (*models.Role, error) <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Get(0).(*models.Role), args.Error(1)
}</span>

func (m *MockRoleRepository) Create(role *models.Role) error <span class="cov0" title="0">{
        args := m.Called(role)
        return args.Error(0)
}</span>

func (m *MockRoleRepository) Update(role *models.Role) error <span class="cov0" title="0">{
        args := m.Called(role)
        return args.Error(0)
}</span>

func (m *MockRoleRepository) Delete(role *models.Role) error <span class="cov0" title="0">{
        args := m.Called(role)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/services"
)

type MockRoleService struct {
        mock.Mock
        services.IRoleService
}

func (m *MockRoleService) Create(role *models.Role) error <span class="cov0" title="0">{
        args := m.Called(role)
        return args.Error(0)
}</span>

func (m *MockRoleService) GetByID(id int64) (*models.Role, error) <span class="cov0" title="0">{
        args := m.Called(id)
        var role *models.Role
        if r := args.Get(0); r != nil </span><span class="cov0" title="0">{
                role = r.(*models.Role)
        }</span>
        <span class="cov0" title="0">return role, args.Error(1)</span>
}

func (m *MockRoleService) Update(role *models.Role) error <span class="cov0" title="0">{
        args := m.Called(role)
        return args.Error(0)
}</span>

func (m *MockRoleService) Delete(id int64) error <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Error(0)
}</span>

func (m *MockRoleService) AssignPermissions(roleID uint, permissionIDs []uint) error <span class="cov0" title="0">{
        args := m.Called(roleID, permissionIDs)
        return args.Error(0)
}</span>

func (m *MockRoleService) GetRolePermissions(roleID uint) ([]models.Permission, error) <span class="cov0" title="0">{
        args := m.Called(roleID)
        return args.Get(0).([]models.Permission), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
)

type MockSettingRepository struct {
        mock.Mock
}

func (m *MockSettingRepository) GetAll() ([]models.Setting, error) <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).([]models.Setting), args.Error(1)
}</span>

func (m *MockSettingRepository) GetByKey(key string) (*models.Setting, error) <span class="cov0" title="0">{
        args := m.Called(key)
        return args.Get(0).(*models.Setting), args.Error(1)
}</span>

func (m *MockSettingRepository) Update(setting *models.Setting) error <span class="cov0" title="0">{
        args := m.Called(setting)
        return args.Error(0)
}</span>

func (m *MockSettingRepository) Create(setting *models.Setting) error <span class="cov0" title="0">{
        args := m.Called(setting)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
)

type MockSettingService struct {
        mock.Mock
}

func (m *MockSettingService) GetSetting() ([]models.Setting, error) <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).([]models.Setting), args.Error(1)
}</span>

func (m *MockSettingService) GetSettingByKey(key string) (*models.Setting, error) <span class="cov0" title="0">{
        args := m.Called(key)
        return args.Get(0).(*models.Setting), args.Error(1)
}</span>

func (m *MockSettingService) Update(setting *models.Setting) error <span class="cov0" title="0">{
        args := m.Called(setting)
        return args.Error(0)
}</span>

func (m *MockSettingService) Create(setting *models.Setting) error <span class="cov0" title="0">{
        args := m.Called(setting)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
        "gorm.io/gorm"
)

type MockUserRepository struct {
        mock.Mock
}

func (m *MockUserRepository) PaginateUser(page, limit int) (*utils.Pagination, error) <span class="cov0" title="0">{
        args := m.Called(page, limit)
        return args.Get(0).(*utils.Pagination), args.Error(1)
}</span>

func (m *MockUserRepository) GetAll() ([]models.User, error) <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).([]models.User), args.Error(1)
}</span>

func (m *MockUserRepository) GetByID(id uint) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Get(0).(*models.User), args.Error(1)
}</span>

func (m *MockUserRepository) Create(user *models.User) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(user)
        return args.Get(0).(*models.User), args.Error(1)
}</span>

func (m *MockUserRepository) Update(user *models.User) error <span class="cov0" title="0">{
        args := m.Called(user)
        return args.Error(0)
}</span>

func (m *MockUserRepository) Delete(userId uint) error <span class="cov0" title="0">{
        args := m.Called(userId)
        return args.Error(0)
}</span>

func (m *MockUserRepository) FindByField(field string, value string) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(field, value)
        return args.Get(0).(*models.User), args.Error(1)
}</span>

func (m *MockUserRepository) GetProfile(id uint) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Get(0).(*models.User), args.Error(1)
}</span>

func (m *MockUserRepository) UpdateProfile(user *models.User) error <span class="cov0" title="0">{
        args := m.Called(user)
        return args.Error(0)
}</span>

func (m *MockUserRepository) GetUserPermissions(userID uint) ([]models.Permission, error) <span class="cov0" title="0">{
        args := m.Called(userID)
        return args.Get(0).([]models.Permission), args.Error(1)
}</span>

func (m *MockUserRepository) CreateWithTx(tx *gorm.DB, user *models.User) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(tx, user)
        return args.Get(0).(*models.User), args.Error(1)
}</span>

func (m *MockUserRepository) GetDB() *gorm.DB <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).(*gorm.DB)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
        "github.com/vfa-khuongdv/golang-cms/internal/models"
        "github.com/vfa-khuongdv/golang-cms/internal/utils"
)

type MockUserService struct {
        mock.Mock
}

func (m *MockUserService) PaginateUser(page, limit int) (*utils.Pagination, error) <span class="cov0" title="0">{
        args := m.Called(page, limit)
        return args.Get(0).(*utils.Pagination), args.Error(1)
}</span>

func (m *MockUserService) GetUser(id uint) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Get(0).(*models.User), args.Error(1)
}</span>

func (m *MockUserService) GetUserByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(email)
        return args.Get(0).(*models.User), args.Error(1)
}</span>

func (m *MockUserService) CreateUser(user *models.User, roleIds []uint) error <span class="cov0" title="0">{
        args := m.Called(user, roleIds)
        return args.Error(0)
}</span>

func (m *MockUserService) UpdateUser(user *models.User) error <span class="cov0" title="0">{
        args := m.Called(user)
        return args.Error(0)
}</span>

func (m *MockUserService) DeleteUser(id uint) error <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Error(0)
}</span>

func (m *MockUserService) GetUserByToken(token string) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(token)
        return args.Get(0).(*models.User), args.Error(1)
}</span>

func (m *MockUserService) GetProfile(id uint) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Get(0).(*models.User), args.Error(1)
}</span>

func (m *MockUserService) UpdateProfile(user *models.User) error <span class="cov0" title="0">{
        args := m.Called(user)
        return args.Error(0)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
